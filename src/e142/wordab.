!* -*-TECO-*- *!
!* This source is compiled with IVORY, not PURIFY!
!* This is what used to be XWORDA, now the official WORDAB.  It will
 * (at least for a while) check when reading word abbrev files and use the
 * WABCON library to convert the old style formats to the one used now (QWABL
 * format).  All mention of QWABL might not want to appear in comments
 * presented to the user and take out other "temporary" sounding things.
 * One note:  old uses of names with & WORDAB were changed to begin & WRDAB,
 * so that doing MM Aproposword wouldn't produce a very confusing list.!

!~FILENAME~:! !Word Abbrev Mode package.  Documentation in INFO under EMACS.!
WORDAB

!& Setup WORDAB Library:! !S Run when WORDAB is loaded.  Calls a hook.
Calls WORDAB SETUP HOOK, if it exists.  That can do things like
    auto-loading a file of abbreviations.
Then appends & WRDAB Set Mode Line Hook to Set Mode Line Hook.
    Thus, anything put on those hook variables should not return by ^\.!

 [1[2				    !* save regs!
 6*5fsQVectoru.e		    !* .E: QVector of random WORDAB variables.!
 m.m& WRDAB Mode or Global Expandu:.e(0)  !* .E(0): abbrev lookup subroutine!
 m.m& Expandu:.e(1)		    !* .E(1): & Expand subroutine.!
 0u:.e(2)			    !* .E(2): abbrev.!
 0u:.e(3)			    !* .E(3): . where expansion/fill starts.!
 0u:.e(4)			    !* .E(4): expansion (maybe auto-filled).!
 0u:.e(5)			    !* .E(5): any text before expansion that!
				    !* filling moved to next line.!

 1,m.m& Setup Compressed WORDAB Librariesu1	    !* 0 if nonexistant!
 q1"n fm1'			    !* Create defaults variables etc.!

 0fo..qWORDAB SETUP HOOKu1	    !* 1: Setup Hook or 0.!
 q1"n m1'			    !* Call the hook if there is one.!
 m.m& WRDAB Set Mode Line Hooku1  !* 1: WORDAB SML hook.!
 0fo..qSet Mode Line Hooku2	    !* 2: Old SML hook.!
 q2"e q1'"# :i*21'm.vSet Mode Line Hookw
				    !* install our SML hook if none previous,!
				    !* otherwise append to SML hook!
 

!Old Word Abbrev Character Describe:! !C Tell what char does after expanding.
This command will ask you to type a character, e.g. Space, which runs the
word abbrev expander and then calls the old definition for that
character.  The description for that old definition will be given, e.g. 
the description for ^R Auto-Fill Space.!

 [0[1
 1,(:i*Type word abbrev key to describe: )m.i	    !* Prompt, prepare!
 @fiu0				    !* 0: 9-bit key code.!
 q0fs^RCMacro-(m.m^R Abbrev Expand And Call Old Char)"n
    q0m(m.m& Charprint)
    ft does not run ^R Abbrev Expand And Call Old Char.  It runs
   q0fs^RCMacro :m(m.mDescribe)'
 8[..e q0:\u1 ]..e		    !* 1: Code as octal string.!
 qMM # WRDAB Old 1u1		!* 1: Old function.!
 ftAfter possibly expanding,  q0m(m.m& Charprint) ft runs 
 q1:m(m.mDescribe)    

!^R Abbrev Expand Only:! !^R Expand last word, but insert nothing after it.
If given an argument, will feep if last word isn't an abbrev.!
!^R Abbrev Expand !		    !* For & Set Word Abbrev Chars.!
 .(				    !* Save point for checking if expanded.!
    0,0a"c m:.e(0)'		    !* Expand!
    )-."e ff"g fg'' 1	    !* Feep if ARG and no expansion.!

!^R Abbrev Expand And Call Old Char:! !^R Expand last word, then run old char.
The "old" function run by the character after the expansion check may be
    described by MM Old Word Abbrev Character Describe which will ask you to
    type the character to describe.
Explicit ARG inhibits expanding.!
!^R Abbrev Expand !
 ff"E			    !* No expanding if an ARG.!
    0,0a"c m:.e(0)''		    !* Expand, no insert.!
 [.1 8[..e q..0fs^RIndirect:\u.1 ]..e	    !* .1: Octal for char.!
 f @:mMM # WRDAB Old .1	    !* Call old char function.!

!^R Abbrev Expand And Self-Insert:! !S Expand last word if an abbrev.
Giving an explicit numeric argument inhibits expansion, just inserting that
    many copies of char that ran this.!
!^R Abbrev Expand !
 ff"e 0,0a"c m:.e(0)''
 f@:m(q..0fs^RIndirectfs^Rinit)

!& WRDAB Mode or Global Expand:! !S Expand previous word if mode or global abbrev.!
 -fwx*[.1 qMode[.2		    !* .1: Last word, .2: Mode name.!
 :fo..qX .1 .2 Abbrevf"lw :fo..qX .1 * Abbrevf"lw''u.2
				    !* .2: Abbrev ..Q offset!
 :m:.e(1)			    !* expand!

!& Global Expand:! !S Expand previous word if global abbrev.!
 -fwx*[.1			    !* .1: Last word!
 :fo..qX .1 * Abbrevf"lw'[.2 !* .2: Abbrev ..Q offset!
 :m:.e(1)			    !* expand!

!& Expand:! !S .1 is abbrev, .2 is ..Q offset
A pre-comma ARG inhibits auto-filling.  (Since ^^M, e.g. is called by
    some to insert CRLF but not auto-fill.)!
!*
Say last word is "foo" and current mode is "ala":
If X foo ala Abbrev (for current mode ala) exists, it has exp.
Else if X foo * Abbrev exists (global abbrev), it contains expansion.
    (Thus any mode abbrev "foo" overrides a global abbrev "foo".)
If expansion occurs:
    If a hyphen to left of last word, and Word Abbrev Prefix Mark points
	before it, then the hyphen is removed, gluing prefix to expansion.
If first letter of abbrev is capitalized, first letter of expansion will
    be capitalized too.
If first and last letter of abbrev is capitalized (e.g. all letters),
    we do more upper-casing, controlled by WORDAB All Caps:
    If 0 then the first letter of each word in expansion is capitalized.
    If non-0 then the entire expansion is upper-cased.
    For one-word expansions, the former choice is meaninless so we do the
    latter, fully upper-casing the single word.
In fill mode, line may be broken.
The comment for the abbrev variable is a string-number that tells the
    number of times the abbrev has been used.!

!*  .E(2) is set to the word replaced.  If there was a
	prefix glued, "-" is prepended.
    .E(3) is set to where expansion/fill starts.
    .E(4) contains (maybe auto-filled) expansion and
	anything before expansion that was also filled.
    .E(5) is any text before expansion that filling
	moved to next line. !

				    !* .1: abbrev.!
				    !* .2: ..Q-offset for abbrev var.!
 [..0				    !* ???!
 q:..q(q.2+2)[.3		    !* .3: usage-count string for ab var.!
 q.3fp-101"N :i:..q(q.2+2)1'	    !* If count was numeric, e.g. set by!
				    !* local mode of file, make string of 1.!
 "# .(g.3)j .(\+1:\u:..q(q.2+2))j fq.3d'    !* Increment usage-count (string).!

 -fq.1d				    !* Delete the abbrev.!
 0,0a--"E			    !* Hyphen to left, !
   -1fo..qWord Abbrev Prefix Mark+1-."E    !* ...and a prefix just before it.!
      :i.1-.1		    !* Update last word to include hyphen.!
      -d''			    !* ...So remove hyphen, gluing prefix on.!


 .u:.e(3)			    !* .E(3): Save point for!
				    !* unexpanding later.!
 .[.4				    !* .4: Point before expansion.!
 g:..q(q.2+1)			    !* Insert the expansion.!
 .[.5				    !* .5: Point after expansion.!
 -1[.7				    !* .7: start at char 0 (we increment 1st)!
 fq.1[.8			    !* .8: get length of Q.1!
 <%.7-q.8;			    !* dont search beyond the end of string!
    q.7 :g.1"a0;'>		    !* but find the first alphabetic char !
 q.7 :g.1"u			    !* 1st letter of abbrev was capitalized.!
     q.4j :fwl			    !* find where to start capitaliztion.!
     1 @fc			    !* So capitalize expansion.!
     q.8-1 :g.1"u		    !* Last letter of abbrev was capitalized.!
      0fo..qWordab All Caps"e	    !* Supposed to uppercase first letters.!
	0u.3			    !* ... .3: 0 word count.!
	:< 2:fwl .-q.5; %.3w	    !* ... .3: Iter over expansion, count!
				    !* ... words.!
	   1 @fc >w		    !* ... Cap each word in expansion.!
	q.3"e q.4,q.5 @fc''	    !* ... One-word expansion means all caps.!
      "#			    !* Supposed to cap whole expansion.!
	q.4,q.5 @fc''		    !* ...So uppercase everything.!
     '				    !* End of first let capped.!
 q.1u:.e(2)			    !* .E(2): Save abbrev for!
				    !* unexpanding later.!
 :i:.e(5)			    !* .E(5): Initially!
				    !* assume that nothing before expansion!
				    !* will be moved to next line by filling.!
 q.5j				    !* Move to end of expansion.!
 q.4,q.5 f			    !* Tell ^R of changes to buffer.!


				    !* In-line, fast auto-filler.!
				    !* This repeats line-breaking if!
				    !* need be since expansion may be!
				    !* several words long. !
 ff-1"G oUPDATE '		    !* No auto-fill if pre-comma ARG.!
 0fo..qAuto Fill Mode"E  oUPDATE '	    !* No break if not in mode.!
 0fo..qFill Columnf"e w fsWidth-10'u.1    !* .1: Fill column.!
 fsSHpos-q.1-2"l oUPDATE'	    !* No break.!
 m.m^R Indent New Comment Line[I   !* I: ^R Indent New Comment Line!
 q.5(:fx.5			    !* .5: Rest of line after expn.!
     )-q.4f<!OUT!		    !* Repeat over expansion.!
       fsSHpos-q.1-2:;		    !* No break.!
       <.-1,(0l.):fb "e f;OUT'    !* Nowhere to break.!
	q.1-fsHpos;>		    !* Repeat til place to break.!
       .-q.4"L .u:.e(3)		    !* .E(3): Update!
				    !* expansion start if filling changed it.!
	       .,q.4x:.e(5)	    !* .E(5): Stuff before!
				    !* expansion that filling moved to next!
				    !* line.!
	       .u.4'		    !* .4: Updated expansion start.!
       @f k			    !* Kill whitespace around break.!
       :fx.3			    !* .3: Rest of line.!
       @mIw			    !* This work for dif modes???!
       :0L.,(:2Lg.3).f>	    !* Tell ^R of fill changes.!
 :l .(g.5)j			    !* End of auto-filler, get rest of line.!

 !UPDATE!

 q.4,.x:.e(4)			    !* .E(4):  Save!
				    !* auto-filled text in case of unexpand.!
 

!^R Unexpand Last Word:! !^R Undo last expansion, leaving the abbrev.
If there was a prefix that was glued onto the expansion, it will be separated
    from the abbrev by a hyphen.
The abbrev's usage-count is decremented.!
!* 
The expansion starts at .E(3) and its text is contained
    in .E(4), as a check against the start.  This text
    may include text before the expansion that was moved to the next line
    by auto-filling.
Replaces expansion with .E(2), the abbrev, preceded by
    .E(5), text that was moved by filling.
.E(2) may start with "-" in which case stuff after hyphen is
    the abbrev; a hyphen is inserted to separate the prefix from abbrev. !

 z-.[.4				    !* .4: Z - original point.!
 fn z-q.4j			    !* When exit, restore orig point.!
 q:.e(2)"e fg @ft
No last expansion 0fsEchoActivew 1 '
 q:.e(2)[.1			    !* .1: String of last abbrev.!
 q:.e(4)[.3			    !* .3: Expansion for that abbrev.!
 0,1 :g.1 [.2			    !* .2: First letter of abbrev.!
 .2--"E			    !* Abbrev/expansion had a prefix.!
    1,fq.1 :g.1 u.1'		    !* .1: Remove hyphen from abbrev.!
 "# :i.2'			    !* .2: Prefix separator or null.!
 q:.e(3)[.5			    !* .5: Start of expansion.!
 1:<q.5j>"N zj'			    !* Go to expansion start.!
 fq.3f~.3"n fg @ft
No last expansion 0fsEchoActivew 1 '    !* tell him!
 fq.3d				    !* Remove the expansion.!
 .,(g:.e(5)			    !* Get pre-abbrev, post-fill text.!
    g.2				    !* Insert any prefix indicator.!
    g.1). f			    !* Get the abbrev and tell ^R of changes.!

 :i*Fundamental fo..qMODEu.2	    !* .2: Mode name.!
 :fo..qX .1 .2 Abbrevf"G u.2'	    !* .2: Mode ab ..q-offset.!
 "# :fo..qX .1 * Abbrevf"G u.2''	    !* .2: Global ab ..q-offset.!
				    !* .2: ..Q-offset for abbrev var.!
 q:..q(q.2+2)[.3		    !* .3: usage-count string for ab var.!
 .(g.3)j .(\-1:\u:..q(q.2+2))j fq.3d	    !* Decrement usage-count (string).!

 1 

!Word Abbrev Mode:! !WORDAB:! !C Mode for expanding word-abbrevs.
No arg or non-zero arg sets the mode, Word Abbrev Mode.
0 arg clears the mode.
Runs Word Abbrev Hook if any, with arg of new mode setting.  If none,
  the following keys are set:
    ^X ^A runs ^R Add Mode Word Abbrev,
    ^X ^H runs ^R Inverse Add Mode Word Abbrev,
    ^X +  runs ^R Add Global Word Abbrev,
    ^X -  runs ^R Inverse Add Global Word Abbrev,
    M-'   runs ^R Word Abbrev Prefix Mark,
    C-M-Space runs ^R Abbrev Expand Only, and
    ^XU   runs ^R Unexpand Last Word.
Giving this command 1 as a pre-comma argument means that you only use global
    abbrevs, and things are set up to be faster (e.g. faster expansion
      checking since it doesn't have to check both global and local abbrevs).
Each of the following chars:
    ~@#;$%^&*()-_=+[]\|:'`"{},<.>/?, Space, Return,
will run ^R Abbrev Expand And Self-Insert, or ^R Abbrev Expand And Call Old
    Char.
Tab runs ^R Abbrev Expand for Tab.!
 [.2[.3
 ff&1"E 1u.3'		    !* .3: Mode on if no arguments.!
 "# "'N,0u.3'		    !* .3: Mode on if non-zero argument.!
				    !* Note that ,0^@ negates its arg.!
 q.3m.vWord Abbrev Modew	    !* Set mode variable.!

 ff&2"n "n m.m& Global Expandu:.e(0)'
	      "# m.m& WRDAB Mode or Global Expandu:.e(0)''

 0fo..qWord Abbrev Hooku.2	    !* .2: Hook function.!

 q.2"N q.3 m.2'			    !* Call the hook, if any.!

 q.3"E				    !* Turn OFF word abbrev mode.!
    q.2"E 0u:.x(U)		    !* If didnt call hook undefine our ^X keys!
	  0u:.x()		    !* ...!
	  0u:.x()		    !* ...!
	  0u:.x(-)		    !* ...!
	  0u:.x(+)'		    !* ...!
    m(m.m& Set Mode Line)	    !* Update modes displayed, and things!
				    !* like auto-filling space.!
    '				    !* End of turn OFF mode.!

 !* Turn ON word abbrev mode.!
 0fo..qWORDAB Ins Chars"E	    !* If no $ins$, !
    :i*!~@#;$%^&*-_=+[]()\|:`"'{},<.>/? 
 m.vWORDAB Ins Charsw
				    !* Let any migrate to $old$ if need.!
    :i* m.vWORDAB Old Charsw'	    !* ...!

 q.2"E				    !* If didnt call hook, set up special !
    m.m^R Unexpand Last Word u:.x(U)		    !* ...^R macros.!
    m.m^R Add Mode Word Abbrev u:.x()	    !* !
    m.m^R Inverse Add Mode Word Abbrev u:.x()  !* !
    m.m^R Add Global Word Abbrev u:.x(+)	    !* !
    m.m^R Inverse Add Global Word Abbrev u:.x(-) !* !
    m.m^R Abbrev Expand Only u... w		    !* C-M-Space.!
    m.m^R Word Abbrev Prefix Mark(!"!) u..'	    !* !
    ff&2"n q:.x()(q:.x(+)u:.x())u:.x(+)	    !* !
	       q:.x()(q:.x(-)u:.x())u:.x(-)''   !* !
 :m(m.m& Set Mode Line)	    !* Update modes displayed and set keys.!

!Define Word Abbrevs:! !C Define word abbrevs from buffer.!
!* Format of buffer:
<buf> ::= null | <defline> <CRLF> <buf>
<defline> ::= <abbrev> : <white> <optionals> <white> " <expansion> "
    <expansion> may be more than one line, and may have '"'s in it as long as
    they are quoted with another '"'.
<optionals> ::= <optmode> <white> <optcount>
<optmode> ::= null | ( <mode> )
<optcount> ::= null | <number>
For now nothing else, no :s in <abbrev>.
<mode> is the name of a major mode (e.g. LISP), if abbrev is to be
    effective only in that mode.  It is ommitted if the abbrev is to be
    effective in all modes.
<number> is a usage-count for the abbrev -- i.e. how many times the
    abbrev has been used before.
<white> is any number (including 0) of spaces and tabs.!

 [.1[.2[.4
 g(q..o(f[BBindw))		    !* Temp buf, init with defns.!
 bj 0s <:s;ric>	    !* Teco-quote alts, ^]s.!
 zj i
				    !* Ensure something after final quote!

 bj
 < .-z;
   :s:; -d			    !* End of <abbrev>.!
   0fx.1			    !* .1: <abbrev>.!
   @f 	k		    !* Remove <white>.!
   0,1a-("E d :flfx.2 d'	    !* .2: <mode> name. )!
   "# :i.2*'			    !* .2: * for global.!
   @f 	k		    !* Remove <white>.!
   @f0123456789 fx.4		    !* .4: <number> usage-count.!
   fq.4"E :i.40'		    !* .4: 0-string by default.!
   @f 	k		    !* Remove <white>.!
   0,1a-34"N :i*No quote to start expansionfsErr
	     '			    !* Ensure format.!
   d i:i*			    !* Delete quote, make command.!
   0s" !'! <:s"e :i*No quote to end expansionfsErr'	    !* !
	     0,1a-":@; c> !'!	    !* Find unquoted doublequote.!
   0,1a-15."n :i*Possible unquoted " in expansion -- final " not at end of linefsErr !''!'
   -d				    !* Remove endquote.!
   iM.VX .1 .2 Abbrevw   !* Make expansion command.!
   i M.CX .1 .2 Abbrev.4	    !* Make set-comment command.!
   l>				    !* Next abbrev defn.!
 j 0s"" <:s; -d>		    !* Take quote-quoters off.!
 m( hx* )			    !* Define by running buffer.!
 

!List Word Abbrevs:! !C List abbrevs and their expansions.!
!* See documentation on Insert Word Abbrevs for details.!
 [.1 f[BBindw			    !* Construct list in temp buffer.!
 m(m.mInsert Word Abbrevs)
 bj i
abbrev: (mode)  count   "expansion"


ht ft
Done.
  

!Insert Word Abbrevs:! !C Insert abbrevs defined and their expansions.
Format is acceptable to MM Define Word Abbrevs.
In particular, any double-quotes (the '"' character) in an expansion will be
    quoted with another double-quote.  E.g. HE SAID "HELLO" becomes HE SAID
    ""HELLO"".!

 [1[2[3[4[5[6
 q..ou1				    !* 1: Original buffer.!
 f[BBind q..ou6 [..o		    !* 6: Temporary buffer.!
 :fo..qX u2			    !* 2: $X ^@$ offset, before any abbrevs.!
 q2"L -q2u2'			    !* 2: $X ^@$ offset, positive.!
				    !* 2: Running ..Q index for abbrevs.!
 q1u..o i

 -l				    !* All abbrev defn lines start and end!
				    !* with CRLF.!
 fq..q/5-q2/3(			    !* Number of var slots to examine in ..Q.!
 q2-1u2				    !* 2: Start ..Q - 1.!
  )< q:..Q(%2)u3		    !* 3: Next variable name.!
     q:..Q(%2)u4		    !* 4: Next variable value.!
     q:..Q(%2)u5		    !* 5: Next variable comment.!
     q4fp"L oNEXT'		    !* Skip variable if value is number.!
				    !* (Local vars become 0 when not in their!
				    !* buffer.)!
     f~(0,2:g3)X "N oNEXT'	    !* Skip this variable if not $X ...$, !
     f~(fq3-7,fq3:g3) Abbrev"N oNEXT'  !* ...or if not $... Abbrev$.!
     2,fq3-7g3		    !* Insert abbrev and mode part of vname.!
     -s d i:		    !* Have abbrev, :, TAB to mode.!
     1a-*"E d'"# i( :l i)'	    !* Null if global, or (<mode>).!
     9i g5 i	" !'!	    !* Get comment (usage count).!
     "f4:"l q6u..o g4	    !* Select temporary buffer to fix up!
	j 0s" <:s; i"> !''! hx4 q1u..o' !'!	    !* quotes -- they have to!
				    !* be quoted with another quote.!
     g4 i"
	!'!			    !* Insert value (expansion).!

     !NEXT! >			    !* Repeat for next variable.!

 

!Make Word Abbrev:! !C Make first string argument expand to second one.
After doing MM Make Word Abbrevfoofind outer otter, typing "foo" will
    automatically expand to "find outer otter".
3rd string argument, if any, is the mode for the abbrev.
No 3rd string argument means use the current mode.
3rd string argument = "*" means this make a global abbrev.
This command defines just one abbrev, as compared to Define Word
    Abbrevs which defines several abbrevs from a list in the buffer.!

 :i*( :i*( :i*[.3)[.2)[.1    !* .1: Abbrev.!
					!* .2: Expansion.!
					!* .3: Mode or * or null.!
 fq.3"E qMODEu.3'			!* .3: Mode or *.!

 q.1,q.2 m(m.m& Check And Make Word Abbrev).3	!* Define.!
 w 1 

!& Check And Make Word Abbrev:! !S ARG1 abbrev, ARG2 expn, string arg mode.
String argument is "*" or space-modename, e.g. " TECO".
Checks for break characters in abbrev (not allowed).!

 :i*[2 [1 [3		    !* 1,2,3: abbrev, mode, expansion.!
 q1[4 [5			    !* 4: Abbrev copy, for letter checking.!
 fq1< 0,1:g4u5			    !* 5: 1st char in rest of abbrev copy.!
       5"b fg @ft
Break chars not allowed in abbrev 0fsEchoActivew 1 '
       1,fq4:g4u4>		    !* 4: Each iter, chop off one letter.!

 m.m& Shorten String[S		    !* S: & Shorten String.!

 0fo..qX 1 2 Abbrevu4	    !* 4: 0 or old expansion.!
 q4"N f=34"N FG		    !* Already defined, ask confirm.!
	 q4mSu4			    !* 4: short form of old expansion.!
	 @ftRedefine "1" from "4"?  !''''!	    !* ...!
	 1m(m.m& Yes or No)"E @ftNot redefined.   !* tell him!
	      0fsEchoActivew 1 ''	    !* dont flush the message!
       "# @ftAlready so defined.   !* tell him, and!
	  0fsEchoActivew 1 ''    !* Dont reset usage-count.!

 q3m.vX 1 2 Abbrevw	    !* Define expansion.!
 m.cX 1 2 Abbrev0		    !* Set usage-count comment string.!

 @:i*|m.m& Make Non-Usage Abbrev Variable[V
q..q[..o
| fo..qLately Changed Abbrevsu4    !* 1: Lately.!

 q3m(m.m& Teco Quote String)u3	    !* 3: Expansion with s, s.!

 @:i*|4
MVX 1 2 Abbrev30|(
    )m.vLately Changed Abbrevsw    !* Update Lately!
 

!Write Incremental Word Abbrev File:! !C Write file of changed abbrevs.
Writes to file given by string argument.
(This does not reset the default filename for Write Word Abbrev File and
 Read Word Abbrev File.  I'm not sure of the correctness of this, though.)
Defaults to home directory, INCABS >.
See Read Incremental Word Abbrev File.!

 [1
 e[e\ fne^e] f[DFile 1f[FNamSyntax	    !* Save I/O channels, filename.!
 etDSK: fsHSNamefsDSNamew etINCABS >    !* Default to home directory.!
 4,fIncremental Filef"e w'u1	    !* Read string argument *!
 f[BBind g(:i* fo..qLately Changed Abbrevs)	    !* Get QWABL file!
				    !* commands for changed abbrevs into!
				    !* temporary buffer.!
 z"e :i*No incremental abbrevs to write fsErr'    !* Better to err than!
				    !* print a message, since more useable!
				    !* by other commands.!

 eihpef1			    !* Write to filename STRARG.!
 er fsIFileu1 ec @ft
Written: 1
 0fsEchoActivew 1

!Read Incremental Word Abbrev File:! !C Load some abbrevs that changed.
String argument is filename that contains incremental abbrev definitions,
    e.g. written by Write Incremental Word Abbrev File.
    Default is home directory, INCABS >.
(This does not reset the default filename for Write Word Abbrev File and
 Read Word Abbrev File.  I'm not sure of this, but it seems correct.)!

 [1 f[DFile			    !* Save default fielname *!
 e[ fne] f[DFile 1f[FNamSyntax   !* Save input channel, filename.!
 etDSK: fsHSNamefsDSNamew etINCABS >    !* Default to home directory.!
 4,fIncremental word abbrev filef"e w'u1	!* Read string argument *!
 et1				    !* Set default from argument *!
 f[BBindw er @y		    !* Read in QWABL file. *!
 m( hx*f(m.vLately Changed Abbrevsw) )	    !* Save it in Lately and!
				    !* then macro it to define abbrevs.!
 				    !* Call it. *!

!& Teco Quote String:! !S Takes string as NUMARG, returns with ^]^]s, ^]s.!
 f[BBind g()			    !* Insert NUMARG into temp buffer.!
 bm(m.m& Teco Quote Area)	    !* Quote in that buffer.!
 hx* 				    !* Return contents as string.!

!& Teco Quote Area:! !S Quote altmodes and ^]s in ARG1,point.!
 .-z(				    !* Save point at end of area. *!
   < .,:fb; ir >   !* Quote altmodes, ^]s.!
   )+zj 			    !* Restore point at area end, exit.!

!^R Inverse Add Mode Word Abbrev:! !^R Define expansion for word before point.
Numeric argument n means nth word before point is to be an abbrev (e.g.
    you thought it already was, and you are now n words beyond).
    No numeric argument means the word just before point, same as argument
    of 1.
Reads a one-line expansion for the abbrev, defines it, and expands it.!

 qMode[.4
 .-z[.0				    !* .0: Orig .-z.!
 -:fwl			    !* Move back to end of abbrev.!
 -fwx*[.1			    !* .1: Abbrev.!
 1,m(m.m& Read Line)Expansion for .4 abbrev ".1": [.2 !''!
				    !* .2: 0 or expansion string.!
 q.2"e 1'			    !* 0, abort.!
 fq.2"e 1'			    !* Null, abort.!
 m(m.mMake Word Abbrev).1.2    !* Current mode abbrev.!
 @m(m.m^R Abbrev Expand Only)f   !* Expand abbrev before point.!
 q.0+zj				    !* Back to orig point.!
 1				    !* Return, display done already.!

!^R Inverse Add Global Word Abbrev:! !^R Define expansion for word before point.
Numeric argument n means nth word before point is to be an abbrev (e.g.
    you thought it already was, and you are now n words beyond).
    No numeric argument means the word just before point, same as argument
    of 1.
Calls & Read Line to get the expansion for that abbrev.  (No multi-line.)
Defines that abbrev, and then expands the abbrev before point.
Aborts if & Read Line is aborted, or if the expansion is null.!

 .-z[.0				    !* .0: Orig .-z.!
 -:fwl				   !* Move back to end of abbrev.!
 -fwx*[.1			    !* .1: Abbrev.!
 1,m(m.m& Read Line)Expansion for global abbrev ".1": [.2 !''!
				    !* .2: 0 or expansion string.!
 q.2"e 1'			    !* 0, abort.!
 fq.2"e 1'			    !* Null, abort.!
 m(m.mMake Word Abbrev).1.2*    !* Current mode abbrev.!
 @m(m.m^R Abbrev Expand Only)f   !* Expand abbrev before point.!
 q.0+zj				    !* Back to orig point.!
 1				    !* Return, display done already.!

!^R Add Mode Word Abbrev:! !^R Reads mode abbrev for words before point.
Negative ARG means to delete the word abbrev.  (If there is no such mode
    abbrev, but there is a global, it asks if it should kill the global.)
Positive ARG (>0) means expansion is last ARG words.
Zero ARG means expansion is between point and MARK.
If FS ^R Mark set, then for any ARG expansion between . and FS ^RMark.
The abbrev is only effective when in the current mode (e.g. LISP).!
 "L f @:m(m.m^R Kill Mode Word Abbrev) '   !* Neg ARG, delete.!
 :i*FUNDAMENTAL fo..qMODE [.1	    !* .1: Current major mode.!
 f @m(m.m& Add Word Abbrev).1.1 Abbrev	    !* Call with SP <mode>!
				    !* for varname, MODE Abbrev as prompt.!
 w 1 

!^R Add Global Word Abbrev:! !^R Reads global abbrev for words before point.
Negative ARG means to delete the word abbrev,
    calls ^R Kill Global Word Abbrev.
Positive ARG (>0) means expansion is last ARG words.
Zero ARG means expansion is between point and MARK.
If FS ^R Mark set, then for any ARG expansion between . and FS ^RMark.
The abbrev is effective in all major modes.!
 "L f @:m(m.m^R Kill Global Word Abbrev) '	    !* Neg ARG, delete.!
 f @m(m.m& Add Word Abbrev)*Global Abbrev	    !* Call with * !
				    !* stringarg for varname, Global... as!
				    !* prompt string.!
 w 1 

!& Add Word Abbrev:! !S Reads an abbrev for words before point.
Stringarg1 is "*" for global abbrev, and space-modename for a mode abbrev,
    e.g. " TECO".
Stringarg2 is & Read Line prompt.
Calls & Read Line to read the abbrev.
ARG non-0 means expansion is last ARG words.  (Includes breaks in between
    words, but not those before first or after last word.)
ARG 0 means expansion is between point and MARK.
If FS ^R Mark set, then for any ARG expansion between . and FS ^RMark.
If the abbrev is already defined, user is asked if redefinition wanted.
The abbrev must not contain any break characters.
Abbrev variable is constructed: X abbreviation <mode/*> Abbrev.  It
    contains a string which is the expansion.!
 :i* [.2			    !* .2: Modename part of varname.!
 [.3[.4[.5.[.6 fnq.6j		    !* .6: Auto-restoring point.!

 1:<fs^RMark+1f"G-1 u.3 1;'	    !* FS ^R Mark$ set, use that to point.!
    "E .(:f(j)u.3)j 1;'	    !* ARG=0, use MARK and validate.!
    "N -fwl .u.3 fwl 1;'	    !* ARG non-0, use last ARG words.!
    >"N FG F*w 1 '	    !* No expansion found.!
				    !* .3: expansion start.!
 Q.3,. fx.3			    !* .3: expansion.!
 m.m& Shorten String[S		    !* S: & Shorten String.!
 m.m& Read Line[R		    !* R: & Read Line.!
 q.3mSu.4			    !* .4: Short expansion string.!
 1,mR for ".4": [.1 !''!   !* .1: Abbrev.!
 q.1"E 1 '			    !* Abort.!

 q.1,q.3 m(m.m& Check And Make Word Abbrev).2   !* Define.!
 1 

 0fo..qAbbrev Auto Save Mode"N	    !* Maybe should otherwise ask?!
    0fo..qAbbrev Auto Save Count+1u.4	    !* In which case this before.!
    q.4-(20fo..qAbbrev Auto Save Delay)"G  !* ...!
	0m.vAbbrev Auto Save Countw
	@ft
(Abbrev Auto Save) m(m.mWrite Word Abbrev File)  !* Use default...!
	0fsEchoActive		    !* dont clear the echo area!
	'"# q.4m.vAbbrev Auto Save Countw''
 1 				    !* Exit.!

!& Shorten String:! !S Produce a short string, showing beginning/end.
ARG is a string pointer.!
 [.3[.4[.5			    !* .3: Long ARG string.!
 fq.3-40"G			    !* If expan is long, only show part.!
    0,16:g.3u.4			    !* .4: first 16 letters of exp.!
    fq.3-16,fq.3:g.3u.5		    !* .5: last 16 letters.!
    :i.4.4.....5'	    !* .4: first and last 16 letters.!
 "# q.3u.4'			    !* .4: expan is short, whole expan.!
 q.4 				    !* Return short string.!

!^R Word Abbrev Prefix Mark:! !^R Mark point as end of a prefix.
Expansion of the prefix may occur unless an ARG is given.
Sets Word Abbrev Prefix Mark to point and inserts a hyphen.!
!^R Abbrev Expand !
 ff"E			    !* No expanding if an ARG.!
    0,0a"c m:.e(0)''		    !* Expand!
 . m.vWord Abbrev Prefix Markw
 .,(i-). 			    !* Hyphen is deleted when!
				    !* expansion occurs.!

!& WRDAB Set Mode Line Hook:! !S Tell & Set Mode Line if display " Abbrev".!
!* *** NOT YET *** Inserts " Abbrev", and passes along any given string (old style
hooks accumulated a string of mode line things instead of inserting).
Call & WRDAB Process Options Hook (isnt anymore on that hook).
This is appended to Set Mode Line Hook.!
+0(fsQPPtr[Q			    !* Q: Unwind to here for auto-popping.!
   )[.0				    !* .0: Previous hooks value.!

 m(m.m& WRDAB Process Options Hook)	    !* This way dont have to call!
				    !* & Process Options every buffer sw.!
 0fo..qWord Abbrev Mode"N	    !* In Word Abbrev Mode.!
    q.0"E :i.0 Abbrev'"# :i.0.0 Abbrev''	    !* .0: Append abbrev.!
				    !* Now return appended strings: !
				    !* (Return by running off, not ^\, so!
				    !* that appending hooks will work.)!
 q.0( qQfsQPUnwindw		    !* Auto-pop all pushed qregs.!
				    !* Next exit with new string.!
				    !* Exit without ^\, no CRLF.!
      )
!^R Kill Mode Word Abbrev:! !^R Causes mode abbrev typed to be expunged.
Same as ^R Add Mode Word Abbrev with a negative ARG.!
 :i*Fundamental fo..qMODE[.2	    !* .2: Mode name.!
 1, m(m.m& Read Line)Kill .2 Abbrev: [.1	    !* .1: Abbrev.!
 q.1"E '			    !* Abort.!
 0fo..qX .1 .2 Abbrev"E	    !* No such mode abbrev.!
    0fo..qX .1 * Abbrev"E	    !* And no global either.!
	FG @ft".1" is neither .2 mode nor global abbrev. !''!
	0fsEchoActivew 1 '	    !* Do nothing, and dont erase message!
    "# FG @ft".1" is not a .2 mode abbrev, but is a global abbrev.
Kill it? !''!
	  1m(m.m& Yes Or No)"E	   !* ask him!
	     @ft Not killed.  0fsEchoActivew 1 '	    !* he said no!
	  :i.2*''		    !* .2: Reset to kill global.!
 m(m.mKill Variable)X .1 .2 Abbrev    !* Expunge abbrev.!

 :i* fo..qLately Changed Abbrevsu.4	    !* .1: $Lately$.!
 @:i*|.4
m(m.mKill Variable)X .1 .2 Abbrev| m.vLately Changed Abbrevsw
				    !* Update lately.!
 w 1 

!^R Kill Global Word Abbrev:! !^R Causes global abbrev typed to be expunged.
Same as ^R Add Global Word Abbrev with a negative ARG.!
 1, m(m.m& Read Line)Kill Global Abbrev: [.1	    !* .1: Abbrev.!
 q.1"E '			    !* Abort.!
 0fo..qX .1 * Abbrev"E	    !* No such.!
    FG @ft".1" is not a global abbrev.  !* so tell him!
    0fsEchoActivew 1  !''! '	    !* and let it stay on the screen!
 m(m.mKill Variable)X .1 * Abbrev	    !* Expunge abbrev.!

 :i* fo..qLately Changed Abbrevsu.4	    !* .1: $Lately$.!
 @:i*|.4
m(m.mKill Variable)X .1 * Abbrev| m.vLately Changed Abbrevsw
				    !* Update lately!
 w 1 

!Kill All Word Abbrevs:! !C No word abbrevs are defined after this.!
!* For use in conjunction with editing what MM Insert Word Abbrevs inserts,
    and then after MM Kill All..., doing MM Define Word Abbrevs.!
 [.1[.2[.3
 q..q[..o zj			    !* Buffer: symbol table.!
 				    !* Will go thru symtab backwards looking!
				    !* for word abbrev variables.!

 :f<!DONE! 15r			    !* At a variable entry.!
    1<				    !* COND.!
       0,2:g(.fsWord)u.3	    !* .3: 1st 2 letters of varname.!
       f~.3X f"N "L f;DONE'	    !* Past abbrevs, done.!
		  1;'		    !* Not abbrev, skip.!
       .fsWordu.3		    !* .3: Variable name.!
       .+5fsWordu.2		    !* .2: Value.!
       q.2fp:;			    !* Value is number, skip this abbrev.!
       fq.3-7,fq.3 :g.3 u.3	    !* .3: Last 7 letters of name.!
       f~.3 Abbrev"E 15d'	    !* This is an abbrev variable, kill it.!
       >			    !* End of COND.!
    >				    !* End of iter over all entries.!
 

!Edit Word Abbrevs:! !C Go into ^R mode, editing word abbrev definitions.
Note that any '"'s are doubled so that the syntax is unambiguous.  E.g.
    if the abbrev 'xsay' is to expand to 'He said "Hello"', then it will be:
    xsay: 	1	"He said ""Hello"""
^R mode is entered.  When exited normally, (e.g. by ^C^C) the buffer will
    be considered as new definitions of word abbrevs.
^G will abort MM Edit Word Abbrevs, leaving word abbrevs untouched.!
 @:i*| 1m.vAbort Edit Word Abbrevsw	    !* Signal abort.!
       fs^RExitw |[.G	    !* Define ^G to signal abort.!
 0m.vAbort Edit Word Abbrevsw	    !* Signal not to abort at start.!
 f[BBind			    !* Get a temp buffer, !
 m(m.mInsert Word Abbrevs) bj	    !* ...and set up list to edit.!
 :i*Edit Word Abbrevs[..J	    !* Set mode line.!
 				    !* Edit.!
 fsEchoDisw CfsEchoDisw	    !* Clear echo area.!
 0fo..qAbort Edit Word Abbrevs"E   !* No abort signalled.!
    m(m.mKill All Word Abbrevs)	!* Erase prev abbrev defns.!
    m(m.mDefine Word Abbrevs)		!* Define new ones from buffer list.!
    @ftWord abbrevs redefined.	    !* Tell user.!
    0fsEchoActivew		    !* Dont clear echo area after!
    '				    !* Done redefinitions.!
 "# FG @ftWord abbrevs NOT redefined.	!* Confirm abort.!
       0fsEchoActivew'		    !* and dont clear echo area after!
 m(m.mKill Variable)Abort Edit Word Abbrevs	    !* Clean up.!
 

!Sort Word Abbrevs:! !C Sort a word abbrev list in the buffer by count.
The most-frequently used abbrevs appear at the top of the list.!
 bj < .-z;			    !* Go thru whole buffer.!
      .-(:l)."E k'"# l'>	    !* Kill blank lines.!

 : 				    !* Sort record is a line.!
     :s"$f"Lw			    !* Goto beginning of expansion.!
	       -fwl \'!'!	    !* Sort key is possible usage-count.!
     l				    !* To end of record.!
 

!& WRDAB Off PO Check:! !S Check list of chars for expanders, fix.
q.1:    List of characters.
q.6:    ^R Macro to check against.
q.7:    Subroutine to call if char runs .6.!
 -1[.4[.5			    !* .4: Index into .1.!
 < %.4-fq.1;			    !* Stop when done with .1.!
   q.4:g.1u.5			    !* .5: Charcode for next INS char.!
   q.5-q.6"E q.5m.7' >	    !* If same, fix it.!
 

!& WRDAB On PO Check:! !S Check list of expand characters for changes and fix.
q.1:    List of characters.
q.6:    ^R Macro to check against.
q.7:    Subroutine to call if change.!
 -1[.4[.5			    !* .4: Index into .1.!
 < %.4-fq.1;			    !* Stop when done with .1.!
   q.4:g.1u.5			    !* .5: Charcode for next INS char.!
   q.5-q.6"N q.5m.7' >	    !* If changed, fix it.!
 

!& WRDAB Process Options Hook:! !S Check for characters to change.
Calls a subroutine to see-if/do any expand characters need updating.
Is a little slow for someone who makes Word Abbrev Mode local.  Could fix.!
 [.0[.1[.6[.7[.8
 0fo..qMM ^R Abbrev Expand for Tabf"EoRST'u.0	    !* .0: Tab expander.!
 0fo..qWord Abbrev Mode"N	    !* word abbrev mode?!
    qI-q.0"n			    !* turn on Tab?!
       qIm(m(m.m& Global or Local)I)MM # WRDAB Old 11
				    !* Yes, save old tab in either global!
				    !* (using .V) or local (using .L) var.!
       q.0uI'			    !* and set it to tab expander.!
    0fo..qMM & WRDAB On PO Checkf"EoRST'u.0	    !* .0: Checker loop.!
    0fo..qMM & WRDAB Turn On Ins Charf"EoRST'u.7 !* .7: Turn on ins.!
    0fo..qMM & WRDAB Turn On Old Charf"EoRST'u.8 !* .8: Turn on old.!
    '				    !* End WAM on conditional.!
 "# qI-q.0"E			    !* Must turn off Tab.!
       qMM # WRDAB Old 11uI'	!* ...!
    0fo..qMM & WRDAB Off PO Checkf"EoRST'u.0	    !* .0: Checker loop.!
    0fo..qMM & WRDAB Turn Off Ins Charf"EoRST'u.7 !* .7: Turn off ins.!
    0fo..qMM & WRDAB Turn Off Old Charf"EoRST'u.8 !* .8: Turn off old.!
    '				    !* End WAM off conditional.!
 0fo..qWORDAB Ins Charsu.1	    !* .1: 0 or inserting breaks.!
 q.1"E :i.1'			    !* .1: Make sure a string.  (But no!
				    !* consing unless have to.)!

 0fo..qMM ^R Abbrev Expand And Self-Insertf"EoRST'u.6	    !* .6: ^R Ins!
 m.0				    !* Check them, fix.!

 0fo..qWORDAB Old Charsu.1	    !* .1: Call-old breaks.!
 q.1"E :i.1'			    !* ...!
 0fo..qMM ^R Abbrev Expand And Call Old Charf"EoRST'u.6   !* .6: Old Char!
 q.8u.7				    !* .7: Old version for m.0.!
 m.0				    !* Check them, fix.!

 				    !* KEEP HERE IF NOT ON HOOK!

 !RST!				    !* Ensure MM-variables exist.!

 m.m& WRDAB Process Options Hookm.vMM & WRDAB Process Options Hookw
 m.m^R Abbrev Expand for Tabm.vMM ^R Abbrev Expand for Tabw
 m.m& WRDAB On PO Checkm.vMM & WRDAB On PO Checkw
 m.m& WRDAB Turn On Ins Charm.vMM & WRDAB Turn On Ins Charw
 m.m& WRDAB Turn On Old Charm.vMM & WRDAB Turn On Old Charw
 m.m& WRDAB Off PO Checkm.vMM & WRDAB Off PO Checkw
 m.m& WRDAB Turn Off Ins Charm.vMM & WRDAB Turn Off Ins Charw
 m.m& WRDAB Turn Off Old Charm.vMM & WRDAB Turn Off Old Charw
 m.m^R Abbrev Expand And Self-Insertm.vMM ^R Abbrev Expand And Self-Insertw
 m.m^R Abbrev Expand And Call Old Charm.vMM ^R Abbrev Expand And Call Old Charw

f:m(m.m& WRDAB Process Options Hook)    !* Try again now.!


!& WRDAB Turn On Ins Char:! !S Make a ^R Abbrev Expand And Self-Insert key.
ARG: 9-bit of key to use.
If is FS^RInit, then becomes expand-ins.
Otherwise becomes a call-old expander, and character is moved from WORDAB
    Ins Chars to WORDAB Old Chars.!

 [.0				    !* .0: Ascii for key.!
 q.0[.4			    !* .4: Keys macro.!
 q.4fp"L			    !* Is builtin.!
    m.m^R Abbrev Expand And Self-Insertu.0   !* Set ins.!
    '				    !* And return.!

 f~.4!^R Abbrev Expand -19"e '   !* If not already an expander, !
 qWORDAB Ins Chars[.1		    !* .1: $ins$!
 f.1[.2		    !* .2: Position in $ins$!
 0,q.2:g.1[.3			    !* .3: Ins chars before this one.!
 q.2+1,fq.1:g.1u.1		    !* .1: Ins chars after.!
 :iWORDAB Ins Chars.3.1  !* $ins$: Take out this char.!
 qWORDAB Old Charsu.1		    !* .1: $old$!
 :i.2				    !* .2: This char, string.!
 :iWORDAB Old Chars.1.2  !* $old$: Add this char.!

 m.m^R Abbrev Expand And Call Old Charu.0    !* Set key.!
 [.6 8[..e :\u.6 ]..e		    !* .6: Octal string for char.!
 q.4m(m(m.m& Global or Local).0)MM # WRDAB Old .6
				    !* Yes, save old char in either global!
				    !* (using .V) or local (using .L) var.!
 

!& WRDAB Turn On Old Char:! !S Make a ^R Abbrev Expand And Call Old Char key.
ARG: 9-bit of key to use.!

 [.0				    !* .0: Old char 9-bit.!
 q.0[.1			    !* .1: Old char macro.!
 q.1fp"G			    !* If not a builtin now, !
   f~.1!^R Abbrev Expand -19"E	    !* If already an  expander, !
     ''			    !* ...then quit while ahead.!
 m.m^R Abbrev Expand And Call Old Charu.0    !* Set key.!
 [.6 8[..e :\u.6 ]..e		    !* .6: Octal string for char.!
 q.1m(m(m.m& Global or Local).0)MM # WRDAB Old .6
				    !* Yes, save old char in either global!
				    !* (using .V) or local (using .L) var.!
 

!& WRDAB Turn Off Ins Char:! !S Reset char ARG to builtin.!
 [.0				    !* .0: 9-bit.!
 fs^RInitu.0 	    !* Reset.!

!& WRDAB Turn Off Old Char:! !S Reset char ARG to what was before.!
 [.6 8[..e :\u.6 ]..e		    !* .6 Octal string for char.!
 0fo..qMM # WRDAB Old .6[.1	    !* .1: Maybe old char function.!
 [.2				    !* .2: 9-bit.!
 q.1u.2 		    !* Reset key.!

!^R Abbrev Expand for Tab:! !^R Expands abbrevs when Tab inserts at point.
If Tab will not insert any whitespace at point, no expansion is attempted.
    (E.g. the Tab is reindenting the line, but point is mid-line.)
Old Tab is in MM # WRDAB Old 11.
Explicit ARG inhibits expanding.!
!^R Abbrev Expand !
 0,0a[.1			    !* .1: Char to left before tabbing.!
 .,.f				    !* Tell  that buffer is modified so!
				    !* that simple-minded tabs calling!
				    !* fs^RInsert wont be too primitive!
				    !* and echo a tab which might thus get!
				    !* echoed twice here.!
 f@mMM # WRDAB Old 11f	    !* Call old Tab.!
 0,0a"B q.1"C			    !* If now break to left and before wasnt,!
				    !* then Tab inserted here.!
    ff"E			    !* Can expand if no ARG.!
       -@f	 k		    !* Kill white to left.!
       0,0a"c m:.e(0)'		    !* Expand!
       f @mMM # WRDAB Old 11f'''	!* Call old Tab function again.!
 1

!& Global or Local:! !S Return Q.L if argument is a local q-register.  Q.V otherwise.!
 [1[2[3[9				!* save regs!
 [ -1:fsQPHome(]*w)u3		!* get home of our q-register argument!
 qBuffer Indexu9 q9+8u2		!* !
 q:.b(q9)-9/2u1				!* !
 q1< q:.b(%2)-q3"e q.L ' %2w >	!* if q-register is local then return!
					!* .L!
 q.V 					!* else return .V!

!Read Word Abbrev File:! !C Define word abbrevs from a file of definitions.
Stringarg is word abbrev definition file.  Default is <homedir>;WORDAB DEFNS.!

 f[DFile 1f[FnamSyntax	    !* Save default filename *!
 0fo..qLast Word Abbrev Filef"n fsDFilew' !* Either last-used or *!
 "#w etDSK:WORDAB DEFNS fsHSnamefsDSnamew'	!* else a default. *!
 4,fWord Abbrev Filef"ew'fsDFilew	!* Read string argument *!
 fsDFilem.vLast Word Abbrev Filew !* save for defaulting *!
 f[BBind er @y		    !* Read in QWABL file. *!

 !* See if old-style format in definition file: !

 10f~m.m& Make "n			!* All QWABL files start that way, and!
    fsDFile[1				!* no old style file can.!
    m(m.mRun Library)WABCONConvert Old Word Abbrev File1
					!* That defined and converted.!
    er @y hx*m.vQWABL Definitionsw	!* Save for fast definition accesses.!
    '					!* Done -- the convert defined them.!

 !* The file is in the new style: !

 hx* m.vQWABL Definitionsw	    !* Save for fast definition accesses. *!
 mQWABL definitions 	    !* Call it. *!

!Write Word Abbrev File:! !C Write a definition file for all defined abbrevs.
Stringarg filename.  Default is WORDAB DEFNS.
Argument present means do not write out usage counts.
Default filenames come from last definition filename used.!
 [.0[.1[.2[.3[.4[.5 f[DFile	    !* save regs!
 1f[FnamSyntax			    !* Lone fn is first fn. *!
 0fo..qLast Word Abbrev Filef"n fsDFilew'
 "#w etDSK:WORDAB DEFNS fsHSnamefsDSnamew'
 4,fWord Abbrev Filef"ew'u.0	!* Read string argument *!
 et.0 fsDFileu.0		    !* .0: Set default fn. *!
 q.0m.vLast Word Abbrev Filew	    !* Save for next time. *!

 f[BBind			    !* Temp buffer. *!
 m.m& Teco Quote Area[Q	    !* Q: & Teco Quote Area. *!
 :fo..qX u.2			    !* .2: $X ^@$ offset, before any abbrevs.!
 q.2"L -q.2u.2'			    !* .2: $X ^@$ offset, positive.!
				    !* .2: Running ..Q index for abbrevs.!
 ff&1"E			    !* QWABL file has usage counts. *!
  ^i|m.m& Make Usage Abbrev Variable[V	    !* V: Will be variable-maker. *!
|'"#				    !* QWABL file has no usage counts. *!
  ^i|m.m& Make Non-Usage Abbrev Variable[V !* V: Will be variable-maker. *!
|'
 iq..q[..o			    !* Will select symtab buffer. *!

 fq..q/5-q.2/3(			    !* Number of var slots to examine in ..Q.!
 q.2-1u.2			    !* .2: Start ..Q - 1.!
  )< q:..Q(%.2)u.3		    !* .3: Next variable name.!
     q:..Q(%.2)u.4		    !* .4: Next variable value.!
     q:..Q(%.2)u.5		    !* .5: Next variable comment.!
     q.4fp"L oNEXT'		    !* Skip variable if value is number.!
				    !* (Local vars become 0 when not in their!
				    !* buffer.)!
     f~(0,2:g.3)X "N oNEXT'	    !* Skip this variable if not $X ...$, !
     f~(fq.3-7,fq.3:g.3) Abbrev"N oNEXT'  !* ...or if not $... Abbrev$.!
     iMV.3		    !* Insert var-maker call, varname. *!
     .(g.4)mQ i		    !* Insert expansion, quote alts, ^]s. *!
     ff&1"E g.5 i'	    !* Insert usage if no argument or only *!
				    !* pre-comma argument. *!
     i

     !NEXT! >			    !* Repeat for next variable.!

 hx* m.vQWABL Definitionsw	    !* Save for quick definition accesses. *!
 1,m(m.m Write File).0	    !* Write it out. *!
 

!Word Abbrev Apropos:! !C List abbrevs or expansions containing stringarg.
String argument is some pattern to find, either in abbrev, modename, or
    expansion.  It is a standard Teco search string;  e.g. you can do:
    MM Word Abbrev Apropos$foo^Obar$ which will match foo OR bar.
Currently this command only works "approximately" -- it may miss definitions
    that have changed via Edit Word Abbrevs, or were only defined by Define
    Word Abbrevs.  It will however catch all definitions read in from a file
    or defined one by one by the user.!

 :i*[0[1				!* 0: String argument to match.!
 f[BBindw				!* Temp buffer.!
 0fo..qQWABL Definitionsu1		!* 1: Get word abbrevs.!
 q1"n g1 j 2:k'				!* ... and kill setup stuff.!
 0fo..qLately Changed Abbrevsu1	!* 1: Add in recent ones.!
 q1"n .(g1)j 2:k'			!* ... and kill setup stuff.!
    !* Those 2:ks leave a blank line at top, for boundary conditions.!

 j <:s
m(m.mKill Variable)X ; 2r .,(:lr).x1	!* 1: Killed abbrev name.!
    0lk fsZ-.fsVZw			!* Will kill instances of that abbrev!
					!* above the point of kill.!
    j<:s
MV1; 0l .,(3s).k>		!* Kill instances of that abbrev.!
    0fsVZw >				!* Look for more to kill.!

 bj <:s
MVX ; 

  >				    !* Separate abbrevs, no funny matches.!

 bj l
 < :s0;			    !* Find a match.!
   -s

 fkc .,(fwl).t ft:	   !* Type abbrev.!
   c 0,1a-*"N			    !* This is a mode abbrev.!
       ft( .,(s Abbrev fkc).t ft)'    !* Type mode if any.!
   ft	"!'!		    !* Type up to expansion.!
   s Abbrev			    !* Find beginning of expansion.!
   .,(sr).t		    !* Find end and type.!
   ft"
  !'!				    !* !
   :s

; >				    !* Ready for next matching abbrev.!

 ftDone.

 

!& Make Usage Abbrev Variable:! !S Like .V and .C combined, for speed.
STRARG1 is abbrev variable name.
STRARG2 is abbrev expansion with altmodes, ^]s quoted with ^]s.
STRARG3 is usage-count string.
Assumes ..Q is selected as buffer (..O).!
 :i*[.1			    !* .1: Abbrev varname. *!
 :i*[.2			    !* .2: Abbrev expansion. *!
 :i*[.0			    !* .0: Usage count string. *!
 :FO..Q.1[.3		    !* .3: Variable index. *!
 Q.3"L -Q.3*5J 15,0I 15R q.1,.FSWORDW 0,.+10FSWORDW	    !* .3 neg *!
       -Q.3U.3'			    !* .3: Pos index. *!
 q.3+1*5j q.2,.fswordw		    !* Stick in expansion string. *!
 5c q.0,.fswordw 		    !* Stick in usage count string. *!

!& Make Non-Usage Abbrev Variable:! !S Like .V and .C combined, for speed.
STRARG1 is abbrev variable name string.
STRARG2 is abbrev expansion string.
Assumes ..Q is selected as buffer (..O).!
 :i*[.1			    !* .1: Abbrev varname. *!
 :i*[.2			    !* .2: Abbrev expansion. *!
 :FO..Q.1[.3		    !* .3: Variable index. *!
 Q.3"L -Q.3*5J 15,0I 15R q.1,.FSWORDW 0,.+10FSWORDW	    !* .3 neg *!
       -Q.3U.3'			    !* .3: Pos index. *!
 q.3+1*5j q.2,.fswordw		    !* Stick in expansion string. *!
 
