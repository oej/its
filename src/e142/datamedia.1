!* -*-TECO-*- !

!~FILENAME~:! !Library to rearrange the command set for easy use from
SRI-style Datamedia keyboards.  Commands are summarized in the file
<EMACS>DATAMEDIA.CHART .!
DATAMEDIA

!& Setup DATAMEDIA Library:! !& Setup macro!

	M(M.MDatamedia)


!Datamedia:! !C Set up the EMACS/Datamedia environment.
Rearranges the command set for easy use from SRI-style
Datamedia keyboards.  Commands are summarized in the file
<EMACS>DATAMEDIA.CHART .!

	Q..$[0		!* An undefined function !

	640 FS Q VECTORU.X	!* Redefine all ^X fns, room for ^X{, etc. !

	2 FS ^R INITu..<
	6 FS ^R INITu..>

	M.M^R_Backward_Wordu..(
	M.M^R_Backward_End-of-WordU:.X(()

	M.M^R_Forward_WordU..)
	M.M^R_Forward_End-of-WordU:.X())

	M.M^R_Beginning_of_Real_Lineu..[
	M.M^R_Back_to_IndentationU:.X([)

	M.M^R_Prefix_MetaU.]
	M.M^R_End_of_Real_Lineu..]

	!* ^^ already is Prefix-Control !
	M.M^R_Up_Real_Lineu..^
	M.M^R_Up_Comment_LineU:.X(^)

	M.MDM_Indent_New_LineuJ
	M.M^R_Down_Real_Lineu..J
	M.M^R_Indent_New_Comment_LineU:.X(12.)

	!*c-r!
	15. FS ^R INITUM
	16. FS ^R INITu..M
	M.M^R_Down_Comment_LineU:.X(15.)

	M.M^R_Goto_BeginningU..{
	M.M^R_Mark_BeginningU:.X({)

	M.M^R_Goto_EndU..}
	M.M^R_Mark_EndU:.X(})

	M.M^R_Previous_ScreenU..+

	M.M^R_Prefix_Control-MetaU.\
	M.M^R_Next_ScreenU..\

	M.M^R_Move_to_Screen_EdgeU..|

	M.M^R_Reposition_WindowU..~

	M.M^R_New_WindowU..=
	M.MDM_Where_Am_IU:.X(=)

	!*delete!
	M.M^R_Backward_Kill_Wordu..
	M.M^R_Backward_Kill_to_End-of-WordU:.X()

	!*Tab, edit-tab!
	11. FS ^R INITUI
	M.MDM_Indent_NestedU..I
	M.M^R_Indent_RigidlyU:.X(9)

	M.M^R_Universal_ArgumentU..*

	M.M^R_Indent_for_CommentU..;
	M.M^R_Set_Comment_ColumnU:.X(;)

	M.M^R_Prefix_MetaU
	M.M^R_Prefix_Control-MetaU..

	M.M^R_Define_Kbd_MacroU../
	M.M^R_Call_Last_Kbd_MacroU:.X(/)

	M.M^R_One_WindowU:.X(1)
	M.M^R_Two_WindowsU:.X(2)
	M.M^R_View_Two_WindowsU:.X(3)
	M.M^R_Modified_Two_WindowsU:.X(4)

	Q0U.@
	M.M^R_Mark_SentenceU..@
	M.M^R_Mark_ParagraphU...@
	
	Q0U.A
	M.M^R_Append_Next_KillU..A
	Q0U...A

	Q0U.B
	M.M^R_Backward_SentenceU..B
	M.M^R_Backward_ParagraphU...B

	Q0U.C
	M.M^R_Center_LineU..C
	Q0U...C

	Q0U.D
	4 FS ^R INITu..D			!*Delete Character!
	M.M^R_Kill_Wordu...D
	M.M^R_Directory_DisplayU:.X()
	M.M^R_Kill_to_End-of-WordU:.X(D)

	Q0U.E
	M.M^R_Exchange_CharactersU..E
	M.M^R_Exchange_WordsU...E
	M.M^R_Edit_FileU:.X()

	Q0U.F
	M.M^R_Forward_SentenceU..F
	M.M^R_Forward_ParagraphU...F
	M.M^R_Find_FileU:.X()

	M.M^R_Goto_Fixed_MarkU..G
	Q0U...G

	Q0U
	M.M^R_Set_Bounds_RegionU..H
	M.M^R_Set_Bounds_FullU..

	17. FS ^R INITU..I			!*Edit-I = Insert CRLF!

	Q0U..J

	Q0U.K
	M.M^R_Kill_Lineu..K
	M.M^R_Kill_Regionu...K
	M.M^R_Kill_into_Q-regU:.X(K)

	12. FS ^R INITU.L
	M.M^R_Lowercase_Wordu..L
	M.M^R_Lowercase_Regionu...L

	M.M^R_Set_Fixed_MarkU..M

	M.M^R_No-opU.N
	M.M^R_Un-killU..N
	M.M^R_Un-kill_PopU...N
	M.M^R_Get_Q-regU:.X(N)

	Q0U.O
	Q0U..O
	M.M^R_Complement_Overwrite_Modeu...O
	M.M^R_Other_WindowU:.X(O)

	Q0U.P
	M.MGoto_PageU..P
	M.M^R_Mark_PageU...P
	M.M^R_Set_Bounds_PageU:.X(P)

	M.M^R_Quoted_InsertU.Q
	M.M^R_Fill_Paragraphu..Q
	M.M^R_Fill_Regionu...Q
	M.M^R_Set_Fill_ColumnU:.X(Q)
	M.M^R_Do_Not_Write_FileU:.X()

	Q0U.R
	M.MDM_Reverse_Character_SearchU..R
	M.MDM_Reverse_Incremental_SearchU...R
	M.MDM_Query_ReplaceU:.X(R)
	M.M^R_Read_FileU:.X()

	Q0U.S
	M.MDM_Character_SearchU..S
	M.MDM_Incremental_SearchU...S
	M.M^R_TECO_SearchU:.X(S)
	M.MDM_Save_FileU:.X()

	Q0U.T
	Q0U..T
	Q0U...T

	Q0U.U
	M.M^R_Uppercase_Wordu..U
	M.M^R_Uppercase_Regionu...U
	M.M^R_Uppercase_InitialU:.X(U)

	Q0U.V
	Q0U..V
	Q0U...V
	M.M^R_Visit_FileU:.X()

	M.M^R_Backward_Kill_WordU.W
	M.M^R_Copy_LineU..W
	M.M^R_Copy_RegionU...W
	M.M^R_Put_Q-regU:.X(W)
	M.MWrite_FileU:.X()

	Q.XU..X
	M.M^R_Execute_Completed_MM_CommandU...X
	M.M^R_Execute_MinibufferU:.X(X)

	Q0U.Y
	M.MSelect_BufferU..Y
	M.MList_BuffersU...Y

	33. FS ^R INITU.Z
	M.M^R_Zap_to_CharacterU..Z
	M.M^R_Zap_thru_CharacterU...Z

	!*Create Fixed Mark Q-vector!
	MM Make_VariableFixed_Mark
	50 FS Q VECTORUFixed_Mark

	!*Buffer creation uses old mode.  Auto Fill is local!
	(@:I* / QMode[A 
		QAuto_Fill_Mode[B /) M.V Buffer_Deselection_Hook
	(@:i* / M(M.M_A_Mode)  		!* Call old mode !
		QB M.L Auto_Fill_Mode
		QB"N 1 M.L Switch_Mode_Process_Options '
		/ ) M.V Buffer_Creation_Hook

	M.V CSearch_Default

	0 M.V Defining_Kbd_Macro
	:i* m.v Last_Kbd_Macro
	20.*5fs q vectoru..m
	q..m[..o hk ]..o
	(@:I* / QDefining_Kbd_Macro"N
		 I_Defining' / ) M.V Set_Mode_Line_Hook

	1 M (M.M Set_Variable_Comment) Indentation_Increment  !*
!		*_Number_of_spaces_per_level_of_indentation

	(M.MDM_Toplevel_^R)FS ^R ENTER
	(M.MDM_Secretary_Macro)U..F
	Q..F U .F

	:IEditor_NameEMACS/Datamedia
	:I..JEMACS/Datamedia_
	M(M.M&_Set_Mode_Line)

	0


!^R Complement Overwrite Mode:!
!^R If Overwrite Mode is on, turn it off.  If it is off,
turn it on.  When Overwrite Mode is on, typed non-meta characters
will delete and overwrite characters in the buffer instead
of being inserted.  Meta characters still function normally.!
	QOverwrite_Mode[1
	Q1"N0U1'"#-1U1'
	Q1UOverwrite_Mode
	Q1FS^RREPLACE
	M(M.M&_Set_Mode_Line)
	0

!Goto Page:! !C Move forward or back by pages, or to specific page.
If no arg, go to top of next page.
If arg is zero, go to top of present page.
If arg is negative, go to top of present page, unless already at top,
	in which case go to top of preceding page.
If arg is positive (+n), go to top of page n of buffer.
If two args (m,n), go to line m of page whatever.!

	f[sstring[1
	QPage_Delimiter[0
	u1ff"e1u1'	!*Default arg to 1!
	"#Q1"G J Q1-1U1''	!*If arg>0, go to top and count from there!
	q1"g q1< :s0  ; >'	!*Search forwards!
	"# Q1"LR'		!*Skip this pagemark if on it and arg<0!
		-:S0 : '	!*Search backwards!
	FF-1"G		!*Pre-comma arg (if any) is line number!
		.U1
		:S0 : .[2	!*Set a limit!
		Q1J -1L	!*Count lines!
		Q2-."L Q2J ' '	!*Don't go beyond end of page!
	0

!^R Copy Lines:! !^R Like killing lines and getting them back,
but doesn't mark buffer modified.!

	.:			!*Set the mark!
	FF"EL'
		"#L'		!*Advance pointer!
	:M(M.M^R_Copy_Region)	!*Do it!

!^R Set Fixed Mark:! !^R Set either THE mark, or special fixed mark.
If no arg, set "ring-of-point" mark.
If arg is zero or positive, set corresponding fixed mark.
There are 10 fixed marks, numbered 0 to 9.  They contain character
counts relative to the beginning of the buffer.  Fixed marks may
be changed only by this macro, and are unaffected by killing, etc.!


	FF"E.:'		!*No arg: set THE mark!
	"#.U:Fixed_Mark()'	!*Else set fixed mark.!
	0


!^R Goto Fixed Mark:! !^R If no arg, exchange point and "ring-of-point" mark.
If negative arg, pop the "ring-of-point" mark.
If zero or positive arg, set "ring-of-point" mark and goto fixed mark.!

	FF"E.(W):'	!*No arg: Exchange point and mark!
	"#"L.:WW1:<>'	!*Neg arg: Pop mark!
	  "#.:		!*Push the mark first!
	    Q:Fixed_Mark()J ' ' !*And go to fixed mark!
	0


!^R Zap to Character:! !^R Kills text up to but not including a
target character.  Uses the macro ^R Character Search to obtain
the target character from the keyboard and search for it.  The search
skips over the character pointed to.!

	.:			!*Push the mark!
	[0 FF"E1U0' "#U0'	!*Default args if necessary!
	Q0"GC' "#R'		!*Skip over first character!
	Q0M(M.M^R_Character_Search)	!*Search!
	"LC' "#R'		!*Exclude the character found!
	:M(M.M^R_Kill_Region)	!*Kill!

!^R Zap thru Character:! !^R Kills text up to and including a
target character.  Uses the macro ^R Character Search to obtain
the target character from the keyboard and search for it.!

	.:			!*Push the mark!
	[0 FF"E1U0' "#U0'	!*Default args if necessary!
	Q0M(M.M^R_Character_Search)	!*Search!
	:M(M.M^R_Kill_Region)	!*Kill!

!^R Forward Word:! !^R Move forward over one word.!

	1:<1A"C1+'1.W:FWL>F"NFG0'
	-1:<2.W:FWL>F"NFG'0

!^R Forward End-of-Word:! !^R Move forward to the next word end.!

	f"LW-':<"L-'.wfwl>"nfg'0


!^R Backward End-of-Word:! !^R Like Backward Word, but moves to end of
previous word.!

	1:<0A"C-1'-1.W:FWL>F"NFG0'
	-1:<-2.W:FWL>F"NFG'0

!^R Kill Word:! !^R Kill next word and trailing delimiters.!

	1[9.[0
	1:<1A"C1+'1.W:FWL>F"NFG0'
	-1:<2.W:FWL>F"NFG0'
	Q0,.:M(M.M&_Kill_Text)

!^R Kill to End-of-Word:! !^R Kill to next word end.!

	[9.,(.wfwr).F:M(M.M&_Kill_Text)


!^R Backward Kill to End-of-Word:! !^R Like Backward Kill Word,
but kills to end of previous word.!

	-1[9.[0
	1:<0A"C-1'-1.W:FWL>F"NFG0'
	-1:<-2.W:FWL>F"NFG0'
	.,Q0:M(M.M&_Kill_Text)

!^R Kill into Q-reg:! !^R Put Q-reg and Kill text!

	1:M(M.M^R_Put_Q-reg)


!^R No-op:! !^R Does nothing.!

	0


!DM Where Am I:! !^R Print various things about the cursor position.
Print the page and line,
the X position, the Y position,
the octal code for the following character,
cursor position in characters and as a percentage of the total file,
and the virtual boundaries, if any.!

	:i*CFSECHODIS
	QPage_DelimiterU3
	[E [B FSBOUNDUEUB
	0,FSZ FSBOUND
	.U0J1U10U4<:S3; .-Q0-2; .U4%1>
	Q4J1U2<L.-Q0-1; .-Z; %2>
	Q0J QB,QE FSBOUND
	@FTPage_Q1@:=
	@FT_Line_Q2@:=
	@ft_X= fs shpos@:=
	@ft_Y= fs ^r vpos@:=
	.-z"n @ft_CH= 8[..e 1a@:=]..e'
	@ft_.= .@:= @ft( .*100/fsz@:= @ft%)
	fsvz+b"n
		@ft_H=< h@:= @ft>'
	@ft_ 1fsechoact 0

!^R TECO Search:! !^R Search, using the basic TECO string search facility.
Special characters:
^B matches any delimiter char.
^N matches any char other than the char following it in the search
	string (i.e., "not").  ^N^B matches non-delimiters, and
	^N^X matches nothing.  ^N^Q^B matches all but ^B, etc.
^O divides the string into substrings searched for simultaneously.
	Any one of these strings, if found, satisfies the search.
^Q quotes the following char, i.e., deprives it of special significance.
	Escape and rubout cannot be quoted.
^X matches any char.!

	1,M(M.M&_Read_Line)Search:[0
	[1 Q1"E1U1'
	Q1:S0"EFG'
	0


!DM Query Replace:! 
!^R Replace string, asking about each occurrence.
Query Replace:FOOBAR displays the next FOO;  you say what to do.
Space => replace it with BAR and show next FOO.
Rubout => don't replace, but show next FOO.
Comma => replace this FOO and show result, waiting for next command.
Period => replace this FOO and exit.  Altmode => just exit.
^ => return to site of previous FOO (actually, jump to mark).
^W => kill this FOO and enter recursive ^R.
^R => enter ^R mode recursively.  ^L => redisplay screen.
Exclamation mark => replace all remaining FOOs without asking.
Any other character exits and is read again.
If QCase Replace is nonzero, BAR will be capitalized or all caps 
if FOO was.
1 MM Query ReplaceFOO... will replace only FOOs that are
bounded on both sides by delimiter characters (according to ..D).!

	FF"N:\'"#:I*'[1
	1,M(M.M&_Read_Line)Query_Replace:[0
	1M(M.MQuery_Replace)0
	


!Grind Sexp:! !C Grind the sexp after the pointer.
A modification of the MIT Grind Sexp that recognizes that
in Interlisp, % quotes a character, " starts a long
string, and ; has no significance.
Uses QMiser Column to decide where to start using "Miser" format,
and QFill Column as the page width to aim for.
Saves the old sexp on the kill ring.!

  1:<
    FDL R			    !* Find the next list.!
    F[VB F[VZ  FL FSBOUND	    !* Narrow bounds to that list.!
    F=MODELISP"N OConfirm'
    z-b-1000"g !Confirm! ^FTDo_you_really_want_to_Grind_this_s-expression?_(Y_or_N):
              FI :FC - Y(  FS Echo Display C FS Echo Display)"N ''
    Z:
    M(M.M &_Save_Region_and_Query) !* No arg so no query, just save region.!
    W J
    [2 [3
!*** Now normalize the expression;  put it into the form PRIN1 would print.!
    [D 128*5,32:ID		    !* In QD make a dispatch that!
       11.*5:F D -D :M2 	    !* turns any whitespace into a single space,!
       15.*5:F D RK :M2 	    !* deletes CRLFs and the indentation after them,!
       12.*5:F D -D :M2 
       %*5:F D C		    !* Handle %'s and "'s right.!
       "*5:F D R ^FLL 
       (*5:F D :M3 	    !* Make sure no whitespace follows ('s and ''s!
  !"!  '*5:F D :M3 
       )*5:F D R M3 C 	    !* or precedes )'s.!
    :I2 Z-.< 1A F_	:; D> 32I 
    :I3 Z-.< 1A F_	:; D> 
    HFD
    J .( 0FS VBW 0L .FS VB )J	    !* Include all of line, up to (, after B,!
				    !* so that FS HPOS is accurate.!
!*** Now decode the grinding parameters.!
    FS WIDTH-10[W		    !* Figure the width to aim at!
    FS WIDTH*2/3[C		    !* and the comment column.!
    0FO ..Q Fill_Column F"N UW
	QWUC'
    -1FO ..Q Comment_Column +1F"G -1UC'
    QC[M			    !* Figure the place to switch to Miser fmt.!
    -1FO ..Q Miser_Column +1F"G -1UM'
    [R :IR /8+1*8
    0FO ..Q Comment_Rounding F"N UR'
    M.M &_Indent [I
!* G gets recursive macro to grind and pass 1 sexp.!
!* It expects numerc arg = depth in parens.!
    [G ^:IG`
	[2 S' R		    !* Pass by all leading quotes.!
	1A-("N ^FWL '	    !* Atoms, just skip over.!
	FL-.-QW++(FS HPOSU2 Q2)"L FLL '	    !* Lists that fit in line, skip over.!
	C Q2-QM"L		    !* If not yet far enough for Miser fmt,!
	   !"!  1A F';()"L ^FWL 1A-32"E C'''	    !* Skip 1st element, so get 2 on 1st line.!
				    !* But if 1st element is a list, use miser fmt anyway.!
	FS HPOS U2		    !* Q2 gets column to put rest of elements at.!
     !LP! 1a-32"E D  O LP'	    !* Don't be confused by whitespace.!
	  1A-)"E C '	    !* Until end of this list,!
	  FS HPOSU3
	  Q3-Q2"N 13I 10I	    !* and for lists, indent to right place!
	    Q2/8,9I Q2&7,32I'
	  +1MG  O LP		    !* and recursively grind.!
	`
    0MG				    !* DO IT!
    J 7F~ (DEFUN_"E		    !* Now, if list is (DEFUN FOO<cr>..., then!
	^FLL 8F=
                ______"E
	     8D	.U3 L		    !* Get the thing after FOO onto first line,!
	     Q3,. F~FEXPR
	       *(Q3,. F~MACRO
	       )"E		    !* and if it is a function property name,!
		 -2D 6D'''	    !* get it on that line too.!
    J HU2U3
    >  !* end errset!
  J Z:			    !* Leave region around the ground sexp.!
  Q3,Q2


!DM Incremental Search:! !^R Search for character string.
As characters are typed in, the accumulated string is
searched for.  Characters may be rubbed out.
^Q quotes special characters.
^S or M-S repeats the search forward; ^R or M-R repeats it backward.
If the accumulated string is empty, ^R, ^S, M-R or M-S either
reverses the direction of search or gobbles the previous
search string and searches for it again.
Altmode or any random control character exits
(anything but altmode is then executed).
If the accumulated string fails to be found,
you will be notified with one bell.  You can then exit,
rub the bad characters out (or ^G them all away),
or try searching in the opposite direction.
Quitting a successful search goes back to the starting
point of the search;  quitting a failing search rubs out
enough characters to make it successful again.
Altmode when the string is empty makes the search
non-incremental by calling ^R String Search.!

	!* Modified to make M-S same as ^S, M-R same as ^R!

    [D			    !* QD is direction and # times to search.!
    0[L				    !* QL > 0 iff failed to find current search string,!
    10.[R			    !* QR is state register: !
				    !* 40. => ^R or ^S repeating search or gobbling default.!
				    !* 20. => trying to exit (altmode or funny ctl char).!
				    !* 10. => just starting.!
				    !* 4 => printing char just read.!
				    !* 1 => rubout that restored point.!

    [Q @:iQ`			    !* MQ pushes current info:  ., qL, q2, q0, qD.!
      q4+1*5-fq3"e		    !* We are going to push in q3, so make sure space exists.!
	q3[..o zj
	200,0i ]..o'
      .u:3(%4)			    !* Push point, search string,!
      qLu:3(%4)
      q2u:3(%4)
      q0u:3(%4)			    !* this character, and current direction of search.!
      qDu:3(%4)
      `

    [T @:iT`
      fs rgetty"n 3.&qR"n	    !* After a rubout, we are redisplaying!
	 fs echo disp T fs echo disp    !* The whole search string, so prepare by!
	 fs echo disp L fs echo disp '' !* erasing the old stuff.!
	@ft 8 :i8	    !*  Update displayed search string.!
      `

    [0				    !* Q0 holds type-in character being processed.!
    [2 :i2			    !* Q2 holds accumulated search string.!
    [8 :i8			    !* Q8 has accumulated stuff to type in echo area.!
    1fo..qSearch_Exit_Option[E	    !* QE nonzero => random control chars exit.!
    200fs q vector [3		    !* Q3 holds stack for partial search strings.!
    -1[4			    !* Q4 is stack pointer.!
    [5				    !* Q5 is random temp.!
    .[P				    !* QP has old point (to maybe push at end).!
    [S :IS M.M&_Isearch_RuboutUS :MS    !* QS has & Isearch Rubout (autoloading)!
    1f[noquit
    [6 [7 [..j			    !* Q6 and Q7 are the success and failure ..J strings.!
    qD"g :i6I-Search__ :i7Failing_I-Search__'
	    !* Either Search or Failing Search appears on --more line.!
    qD"l :i6Reverse_I-Search__ :i7Failing_Reverse_I-Search__'
    0[I				    !* QI is nonzero when we are reading input.!

    fs rgetty"n
	 fs echo disp T fs echo disp    !* The whole search string, so prepare by!
	 fs echo disp L fs echo disp    !* erasing the old stuff.!
	@ft Search:_ -1fstypeo'
      "# @ft _S:_ 1fstypeo'	    !* Set FS TYPEOUT to prevent M.I from doing ^ V.!

  !Restart!

    1:< 1uI -2f[noquit		    !* Set up an errset to catch quits.!
     < qL"e q6' "# q7'u..j	    !* Say in --more-- line whether search is winning.!
      0@V 1uI 2,m.iw :fiu0 0uI @fiu5
      q5-"e fq2:@; !<! 0;> 0fsnoquitw qD:m(m.m ^R_String_Search)'
      q5-8"e  o Funny'
      q5-176."g  o Funny'
      q5-
"e 
FS REREAD'

   !Normal!

      4uR			    !* Handle printing char.!
      mQ			    !* Push ., qL, q2, q0 and qD into q3, for rubbing out.!
      :i2 2 0	    !* stick this char at end of search string,!
      fq8"n mt'			    !* Update the display.!
      @ft 0 "#

   !Try!  !* Note if fall through we are inside a failing conditional.!

        mt			    !* Update the displayed search string.!
        1&qR"n !<!>'		    !* Don't search after rubout that restored point properly.!
	'
      qL"n !<!>'		    !* No point in searching if know it would fail.!

      .u5
      40.&qR"e			    !* For ^S, ^R suppress the moving back so don't no-op.!
	qD"g fq2-1r'		    !* Move back, so that from FO/\O we find the FOO.!
	  "# fsz-qP f[ vz
	     fq2-1"g fq2:c"e zj''
	     f]vz''		    !* After finding FO backwd, move fwd 3 so can find FOO.!
      qD:s2"l !<!>'
      q5j 1uL fg !<!>		    !* But if search fails, undo that motion back.!

   !Funny!

      q5-177."e  o Rubout'
  !* Only control characters and backspace get past here.!
      q5&137.-S"e Q5-600."L o Forward''    !* Check for C-S and M-S (ignore case bit).!
      q5&137.-R"e Q5-600."L o Backward''   !* Note: mustn't change q5 since Control rereads it.!
      q5&537.-Q"e  o Quote'
      qE"e  o normal'
      o Control

   !Quote!	!* ^Q quotes the next character.!

      fs osteco"n -1f[helpch'
      2,m.i fiu0
      fs osteco"n f]helpmac'
      o normal

   !Forward!      !* ^S means search again forward.!

      qD"l :i6I-Search :i7Failing_I-Search'
      q4"L qD"g  o Default'	    !* ^S as 1st char going fwd => gobble default string.!
	     "# 1uD !<!>''	    !* ^S as 1st char, going backward, changed to fwd.!
      mQ			    !* Push ., qL, q2, q0 and qD into q3.!
      qD"L 0uL'			    !* If reversing direction, don't assume search will fail.!
      1uD			    !* String not null:  make sure going fwd,!
      40.uR			    !* Mark us as a ^S so don't change search string,!
      o try			    !* just search for it a second time.!

   !Backward!      !* ^R means search again backward.!

      qD"g :i6Reverse_I-Search :i7Failing_Reverse_I-Search'
      q4"L qD"l  o Default'	    !* ^R as 1st char going backwd => gobble default string.!
	     "# -1uD !<!>''	    !* ^R as 1st char, going forward, changed to backwd.!
      mQ			    !* Push ., qL, q2, q0 and qD into q3.!
      qD"g 0uL'			    !* If reversing direction, don't assume search will fail.!
      -1uD			    !* String not null:  make sure going backwd,!
      40.uR			    !* Mark us as a ^R so don't change search string,!
      o try

   !Default!	!* Come here to use default search string.!

      mQ			    !* Push current state so can rub the default out.!
      qSearch_Default_Ring[..o    !* Find the default!
      .fs word u2  ]..o	    !* and gobble it.!
      fq2"l :i2'
      q2u8
      40.uR			    !* Inhibit moving back before starting to search.!
      o try

   !Rubout!
 
      q4"l fg !<!>'		    !* Rubout when string is empty does nothing.!
      ms			    !* Call & Isearch Rubout.!
      o try

   !Control!

      q5 fs reread
      0;

      >>u0 @feqit-q0"e @fg	    !* If we quit, was it successful or not?!
	     QL"g <ms -ql;>  mt	    !* If failing, rub out the unfound chars and restart.!
	          o Restart'
	     qI"e ms mt o Restart' !* If quit while actually searching, restart.!
	     QPJ 0fsnoquit
	        -1fsquit''	    !* If succeeding, restore starting point and quit.!
	q0f"n fs err'		    !* Error not a quit => pass it on.!

    fq2"g
      qSearch_Default_Ring [..o   !* New search char, save prev default.!
      fq(.fsword)-1"G 5c .-z"e j'' !* If previous default is worth saving, push it!
      q2,.fsword		    !* Store current (new) default!
      ]..o'

    @ft  			    !* Echo an altmode to show we have exited.!
    qP mMM_&_Maybe_Push_Point	    !* Maybe leave mark at place search started.!
    0

!DM Reverse Incremental Search:! !^R Incremental Search Backwards.
Calls Incremental Search with a negative argument.!

	-@:M(m.mDM_Incremental_Search)


!DM Character Search:! !^R Search backward for a single character.
Special Characters:
   ^A	Call ^R String Search; use MM Describe to see what that does.
   ^F	Position window so search object is near top
   ^Q	Quote following character
   ^R	Reverse search direction and read another char
   ^S	Search for default
        Also done if character macro is called by is typed again,
	overides any other function of that character shown here.
   ^T	Search for Teco default
If ^S is not used, the character typed becomes the default
for future searches.  Defaults are kept separate
from the regular TECO "S" command and from Incremental Search.!

    [0 [1[2 0[3 [9
!RDCH! M.I @:FIU0		    !* Q0 gets 12-bit command char!
    FIU9			    !* Q9 gets actual ascii char!
    Q0-(FS^RLAST)"E F[S STRING    !* If repeat char called by use default.!
	QCSearch_DefaultFSS STRING
	OSEARCH '
    Q0:FCU0			    !* Uppercase char!
    Q0-301."E			    !* ^A call other macro.!
	Q1:M(M.M^R_String_Search)'
    Q0-306."E 1u3 oRDCH '	    !* ^F set flag to bring to top!
    Q0-321."E M.I FIU9 '	    !* ^Q read another character, don't check for special.!
    Q0-322."E -Q1U1 ORDCH '	    !* ^R reverse direction and read another.!
    Q0-323."E F[S STRING	    !* ^S use default.!
	QCSearch_DefaultFSS STRING
	OSEARCH '
    Q0-324."E '			    !* ^T use teco default. -- note else clause next line.!
    "# F[S STRING 0S9 '	    !* normal character, compile search for it.!
      FSS STRINGuCSearch_Default  !* Store current (new) default!
!SEARCH!
    .U0 Q1:S"E FG '		    !* Do the search, ding if error !
    Q0M(M.M&_Maybe_Push_Point)	    !* Maybe remember where we came from.!
    q3"N 2fo..Q Next_Screen_Context_Lines :f '	!* ^F search, adjust window!
    1 

!DM Reverse Character Search:! !^R Search backward for a single character.
Special Characters:
   ^A	Call ^R String Search; use MM Describe to see what that does.
   ^F	Position window so search object is near top
   ^Q	Quote following character
   ^R	Reverse search direction and read another char
   ^S	Search for default
        Also done if character macro is called by is typed again,
	overides any other function of that character shown here.
   ^T	Search for Teco default
If ^S is not used, the character typed becomes the default
for future searches.  Defaults are kept separate
from the regular TECO "S" command and from Incremental Search.!

	-@:M(m.mDM_Character_Search)


!LISP Mode:! !C Sets things up for editing LISP code
within the Datamedia environment.!

	M(M.M&_Init_Buffer_Locals)
	
	M.M^R_Indent_For_LISPM.Q..	
	M.M^R_Mark_SexpM.Q.@
	M.M^R_Mark_DefunU:.X(@)
	M.M^R_Backward_SexpM.Q.B
	M.M^R_Backward_ListM.Q..B
	M.M^R_Backward_Up_ListM.Q...B
	M.M^R_Beginning_of_DefunU:.X(B)
	M.M^R_Kill_SexpM.Q.D
	M.M^R_Exchange_SexpsM.Q.E
	M.M^R_Forward_SexpM.Q.F
	M.M^R_Forward_ListM.Q..F
	M.M^R_Forward_Up_ListM.Q...F
	M.M^R_End_of_DefunU:.X(F)
	
	1,(:I*(*_)M.LComment_Start
	1,(:I*))M.LComment_End
	1,(:I*) M.L Paragraph_Delimiter
	0FO..Q LISP_..D F"E	    !* Select the LISP-mode syntax table!
      	 			    !* creating it if doesn't exist.!
	!"! :I*_A____A____A____A____A____A____A____A____A______________A_________
____A____A____A____A____A____A____A____A____A____A____A____A____A____A____A____A____A____A_________A____|____A___AA___A/____A____'____(____)____A____A____A____A___AA____A___AA___AA___AA___AA___AA___AA___AA___AA___AA___AA____A____A____A____A____A____A____A___AA___AA___AA___AA___AA___AA___AA___AA___AA___AA___AA___AA___AA___AA___AA___AA___AA___AA___AA___AA___AA___AA___AA___AA___AA___AA____A____A____A____A____A____A___AA___AA___AA___AA___AA___AA___AA___AA___AA___AA___AA___AA___AA___AA___AA___AA___AA___AA___AA___AA___AA___AA___AA___AA___AA___AA____A____A____A____A________ M.V LISP_..D
        Q LISP_..D' M.Q ..D
	Q.0,1M(M.M&_Set_Mode_Line)LISP

!SAIL Mode:! !C Sets things up for editing SAIL programs!

	M(M.MLoad)SAIL		!* Need to load the file first !
	:M(M.MSAIL_Mode)		!* Call the redefined setup macro !


!MIDAS Mode:! !C Set things up for editing MIDAS code.
M-F and M-B go to address and AC fields, respectively.
C-M-F and C-M-B go to next and previous label.
Paragraphs are delimited only by blank lines.!

    M(M.M &_Init_Buffer_Locals)    !* See comment at top of file.!
    1,(:I*;) M.L Comment_Start
    1,(:I*) M.L Paragraph_Delimiter
!*** Save time by doing the M.M's only once, the first time MIDAS Mode is called.!
    0fo..q MIDAS_Vector[1
    q1"e 5*5fs qvectoru1 q1m.v MIDAS_Vector
         m.m ^R_Go_to_AC_Fieldu:1(0)
	 m.m ^R_Kill_Terminated_Wordu:1(1)
	 m.m ^R_Go_to_Address_Fieldu:1(2)
	 m.m ^R_Go_to_Next_Labelu:1(3)
	 m.m ^R_Go_to_Previous_Labelu:1(4)'
    1,Q:1(0)  M.Q ..B
    1,Q:1(2)  M.Q ..F
    1,Q:1(3)  M.Q ...F
    1,Q:1(4)  M.Q ...B
    Q.0,1M(M.M&_Set_Mode_Line) MACRO 

!MACRO Mode:! !C Set things up for editing MACRO code.
M-F and M-B go to address and AC fields, respectively.
C-M-F and C-M-B go to next and previous label.
Paragraphs are delimited only by blank lines.!

	:M(M.M MIDAS_Mode)


!TECO Mode:! !C Set things up for editing TECO code.
Makes Rubout the Tab-hacking Rubout.
Loads the PURIFY library.  Makes comments be bounded by "* " and "".
M-F moves forward over a TECO conditional;  M-B, back.!

	M(M.M&_Init_Buffer_Locals)
	1,(:I*!*_)M.LComment_Start
	1,(:I*!)M.LComment_End
	1,(:I*)M.LParagraph_Delimiter
	1,Q(1,Q.M.Q)M.Q.
	1,M.M&_FILE_PURIFY_LOADED"E
		F[DFILEM(M.MLoad_Library)PURIFY'
	m.m^R_Backward_TECO_ConditionalM.Q..B
	m.m^R_Forward_TECO_ConditionalM.Q..F
	0FO..Q TECO_..D F"E	    !* Select the TECO-mode syntax table!
      	 			    !* creating it if doesn't exist.!
	!"! :I*__________________________________________________________________
_____________________________________________________________________A_____________________________A____A____A____A____A____A____'____(____)____A____A_________A____A____/___AA___AA___AA___AA___AA___AA___AA___AA___AA___AA____A____;____A____A____A____A____A___AA___AA___AA___AA___AA___AA___AA___AA___AA___AA___AA___AA___AA___AA___AA___AA___AA___AA___AA___AA___AA___AA___AA___AA___AA___AA____A____A____A____A____A____A___AA___AA___AA___AA___AA___AA___AA___AA___AA___AA___AA___AA___AA___AA___AA___AA___AA___AA___AA___AA___AA___AA___AA___AA___AA___AA____A____|____A____A________ M.V TECO_..D
        Q TECO_..D' M.Q ..D
	Q.0,1M(M.M&_Set_Mode_Line)TECO

!Text Mode:! !C Set things up for editing English text.
Makes Auto Fill not indent new lines;  says there are no comments.!

    M(M.M &_Init_Buffer_Locals)    !* See comment at top of file.!
    1,0M.L Space_Indent_Flag
    0FO..Q Text_..D F"E	    !* Select the Text-mode syntax table!
      	 			    !* creating it if doesn't exist.!
	!"! :I*__________________________________________________________________
_____________________________________________________________________A_____________________________A____A____A____A____A____A___A'____(____)____A____A_________A____A____/___AA___AA___AA___AA___AA___AA___AA___AA___AA___AA____A____;____A____A____A____A____A___AA___AA___AA___AA___AA___AA___AA___AA___AA___AA___AA___AA___AA___AA___AA___AA___AA___AA___AA___AA___AA___AA___AA___AA___AA___AA____A____A____A____A____A____A___AA___AA___AA___AA___AA___AA___AA___AA___AA___AA___AA___AA___AA___AA___AA___AA___AA___AA___AA___AA___AA___AA___AA___AA___AA___AA____A____|____A____A________ M.V Text_..D
        Q Text_..D' M.Q ..D
    Q.0,1M(M.M&_Set_Mode_Line) Text 

!& SAI Mode:! !S Setup for SAIL.!
    :M(M.M SAIL_Mode)

!& LSP Mode:! !& LISP Mode:! !S Setup for LISP.!
    :M(M.M LISP_Mode)

!& PUB Mode:! !S Setup for Text mode.!
    :M(M.M Text_Mode)

!Auto Fill Mode:! !C Turn Auto Fill mode on or off.
No arg or argument of 1 turns the mode on;
any other arg turns it off.
When it is on, lines are broken at the right margin
(position controlled by QFill Column) at spaces,
by doing a LF.!

	!* Altered to set up Switch Mode Process Options, because
		Auto Fill Mode is now a local variable !
	-1*(FF)"E1'"#0'UAuto_Fill_Mode
	1 M.L Switch_Mode_Process_Options
	M(M.M&_Process_Options)
	M(M.M&_Set_Mode_Line)
	0

!DM Indent New Line:! !^R Inserts CRLF, then indents the second line.
Any spaces before the inserted CRLF are deleted.
Uses the definitions of CR and Meta-Tab to do the work,
except that if there is a Fill Prefix it is used to indent.
An argument is passed on to the definition of Meta-Tab.!

    @-F_	K		    !* Leave no spacing behind us at end of line.!
    .(  @MM			    !* Run this user's CR definition to insert a CR!
	0fo..q Fill_Prefix[3	    !* If a prefix is defined, put it on new line.!
	fq3"g g3'
	   "# 0f FM..I'	    !* Else run the Tab definition to indent.!
        ),.			    !* f prevents it from typing out.!


!DM Indent Nested:! !^R Indent line for specified nesting level.
With no argument (or argument 1) indents the line at the same nesting
level as the last nonblank line (ie, directly under it).
A larger argument means that this line is that many levels
closer to the surface, and should indent under the last line
above it whose level is the same.  The previous lines are scanned
under the assumption that any line less indented than its successors
is one level higher than they.
A negative arg N indents to the right of the previous nonblank line;
the amount of additional indentation is N times Q$Indentation Increment.
Unindented lines and comment lines are ignored.
If the cursor is not at the beginning of a line, the whole line
is indented, but the cursor stays fixed with respect to the text.!

    [.4 .[.2			    !* Save where to indent from.!
    100000[.3			    !* last nonblank line counts as 1st level.!
    QComment_Start[.5

    "G' "#1'<		    !* Back ARG levels.!
        <			    !* Back 1 level.!
	  0@l @-f		    !* Back to a non-blank line.!
	  l b-.;
	  0@l @f_	r	    !* Back to after its indentation.!
	  fq.5f"g f~.5"e !<!>''   !* Lines that start with comments don't count.!
	  fs shposu.4		    !* Get this line's indentation.!
	  q.4"e !<!>'		    !* Unindented lines don't count.!
	  q.4-q.3:;		    !* Exit if less indented than lower lines already seen.!
	  >
        q.4u.3 >		    !* Update last level indentation.!
    fs hposu.4			    !* Column to indent to.!
    "L -*QIndentation_Increment+Q.4U.4 '
				    !* Negative arg means additional spaces !
    q.2j z-.u.2 @0l		    !* So go back to point we started at and indent.!
    q.4m(m.m&_indent) (	    !* contrive that if point is after the indentation,!
       z-q.2,.fj)		    !* it is fixed wrt text, else goes after indentation.!

!Startup Datamedia:! !C Initialize for editing, process JCL and edit.
Intended to be called from the user init file, instead of reading
<EMACS>EMACS.INIT.!

!* Code mainly taken from EMACS.INIT !

!* Anything in the buffer when you start this will be used
instead of the JCL.!

    ^:I..L`
	FSECHOLINES-3"G3FSECHOLINESW'
	:M(M.M DM_Toplevel_^R)
	`
    Q..9"E Q..LU..9'

    FQ(0FO..QAuto_Save_Filenames)-1"L
      FS MSNAME:F6[0
      FS U INDEX+100000 :\ [ 1
      :I*DSK:<0>AUTOSAVE..1 M.VAuto_Save_Filenames ]1 ]0'

    !*Create MM Quit variable!
    :FO ..Q MM_Quit "L M.VMM_Quit '

    FS XJNAME :F6 [J

    FS MSNAME FS D SNAME
    QFind_File_Inhibit_Write UInhibit_Write

!* Process the JCL!
    0[0 0[1
    Z"E FJ' ZJ			!* Get JCL, or use whatever previous init file left in buffer.!
    ."N				!* Process JCL command - extract filenames and commands!
       0,0A-
"E -D'		    !* REMOVE LF AT END IF ANY *!
       J :S"N .,Z^ FX1 -D'   !* IF COMMANDS TO EXECUTE, PUT THEM IN Q1!
       HFX0'			    !* IF FILE TO BE READ, PUT NAME IN Q0!
    FS LISPT"N FS CCL FNAMU0
        0FS SUPERIOR		    !* Dont try to suck in LISPT.!
        0U1 F~JSNDMSG"E M(M.M TEXT_MODE)''

    HK 0FS MODIFIED
    Q0"E Q1"E 			!* If no commands / file to read, offer help.!
	qEMACS_Version:\[1	    !* get version no. as string!
	FTEMACS/Datamedia_Editor,_version_1_-_type_^__(the_"hold"_key)_for_help.
	]1
	!''! ''
    FQ0-1"L Q1"N M1'		    !* No file specified => execute commands from JCL!
            ]1 ]0 ]J :M..9'         !* and enter ^R mode.!

    QInhibit_Write,M(M.M Visit_File)0 !* VISIT SPECIFIED FILE, USING ">' AS DEFAULT FN2!
    FSLISPT"N F~JSNDMSG"N	    !* If called by EXEC EDIT command...!
        QBuffer_Filenames F[ DFILE
	0 FS DVERS		    !* Reset version number defaults.!
	FS DFILE UBuffer_Filenames
	M(M.M&_Set_Mode_Line)
	F] D FILE''

    Q1"N M1'			    !* If JCL held commands, execute them.!

    ]1 ]0 ]J :M..9		    !* Enter ^R Mode !

!^R Define Kbd Macro:! !C Begin defining keyboad macro.
After you type this command, until you type it again,
everything you type becomes
part of the accumulating keyboard macro as well as being executed.!

    qDefining_Kbd_Macro"E		!* Begin definition !
      0 fs b consm.v Kbd_Macro_Defining_Body
      0 m.v Kbd_Macro_Defining_Index
      m.m &_Define_Kbd_Macro fs tyi sink
      1uDefining_Kbd_Macro
      :M(M.M&_Set_Mode_Line)'
    "#					!* End definition !
      qKbd_Macro_Defining_Body[..o
      qKbd_Macro_Defining_Indexj .,zk	!* Flush the End Kbd Macro command from the string.!
      j < :s; ric >    !* Quote all altmodes and ^]'s.!
      j i !temp!m(m.m&_immediate_Kbd_Macro)   !* Put command to call kbd macro at beginning.!
      zj 27i			    !* Put altmode at end.!
      hx* m.v Last_Kbd_Macro	    !* make mLast_Kbd_Macro call the macro.!
      Q..o( ]..o
	    ) fs bkill		    !* Flush the data structures used in defining.!
      0 fs tyi sink
      0uDefining_Kbd_Macro
      :M(M.M&_Set_Mode_Line)'


!DM Save File:! !^R Save Buffer on Disk if Modified.
With zero arg, use Auto Save Filename,
else use Buffer Filename.!

	"E :M(m.m^R_Save_File) '
	1:M(m.m^R_Save_File)


!^R Save File:! !^R Save buffer on disk if modified.
Auto Save mode uses this macro.
If auto-saving is enabled, then we write to filenames read
or to a separate auto-save filename.  If auto-saving is off,
or if given an argument, we always write to the filenames read.
"1," as argument indicates that this call was not explicitly
requested, and the user should be asked to confirm if
the file has become a lot smaller.  "2," means an auto save,
which should abort if the file is shrunken.!

    0FO..QDebug_Save_File"N SFORCE_ERROR'
    Q..F-Q.F"N 0'
    QAuto_Save_Mode[1
    FS MODIFIED"E		    !* Don't write buffer if not changed since last time, unless!
      FF&1"N		    !* we have an argument (save as real names, not auto save),!
        QAuto_Save_Count"N	    !* we did autosaves since last rewrite of actual file,!
	  Q1-2"E		    !* and those auto saves used _^RSV names.!
				    !* In this case, although file was written, it wasn't!
				    !* written out as the visited filenames.!
	    -1FS MODIFIED''''	    !* So we must write it now anyway.!
    FS MODIFIED"E		    !* If don't need to write since no changes,!
      @FT			    !* tell the user so.!
      (No_changes_need_to_be_written)
       0FS ECHO ACT'
    QBuffer_Filenames[0	    !* Q0 gets appropriate filenames to save as.!
    1[2				    !* Q2 has 1 if saving as buffer filenames, -1 if not.!
    Q1-2"E FF&1"E
	QAuto_Save_FilenamesU0 -1U2''
    Q0"E "N '		    !* Can't save => if implicit, just don't.  Explicit => err!
	 :I*No_filenames_to_save_under FS ERR'
    "N 3*FSZ-(2*QAuto_Save_Size)"L	    !* If file has shrunk, ask for confirmation.!
	   -2"E @FT
(File_has_shrunk_--_not_auto-saving) 0FSECHO ACT'
	   0F[TYI SOURCE
	   @FT
File_has_shrunk_a_lot.__Save_anyway
	   @FG 1M(M.M &_Yes_or_No)"E 0FS ERR'''
    Q0F[D FILE
    Q2"G			    !* If saving for real, not as auto save filenames,!
     FS D DEVICE-(F6DSK)"E	    !* If disk (ie, can be opened fast)!
       1:< ER FS IF CDATE[4 EC    !* See if date of existing file matches when we last!
	   Q:.B(QBuffer_Index+8)[3	    !* read or wrote the file.!
	   Q4"N Q3"N Q4-Q3"N	    !* If not, warn user he may be losing.!
	      FT This_file_has_been_written_on_disk_since_you_last_read_or_wrote_it.
		 Should_I_write_it_anyway
	      M(M.M &_Yes_or_No)(FSwindow+b,zf 0u..h)"E 0'''' >''
    Q2,M(M.M Write_File)0
    Q1"N
      %Auto_Save_Count
      FS D VERSIO"E		    !* If auto-saving as something >,!
      Q1-2"E FF&1"E 1:<ED_< !>!>	    !* If saving as special auto save filenames, delete oldest save.!
         ''
      "# QAuto_Save_Count-QAuto_Save_Max"G	    !* If saving as visited names,!
	 %Auto_Save_DeleteF"G FS D VERSIO
	   1:<ED>'''''		    !* If have accumulated enough saves, delete oldest one.!
    FF&1"N 0UAuto_Save_Count' !* After ^U^X^S, most recent version is NOT an auto save file.!
    0

!DM Toplevel ^R:! !S Enter a loop entering ^R mode within a catch.
Useful as a toplevel macro to be assigned initially to FS ^R ENTER.
The macro MM Top Level will then pop up and into the outermost ^R.
If Q^R Exit Flag is zero, then ^Z will revert to the TECO command loop.
Otherwise if QMM Quit is a string, then it will be macroed.
Otherwise, the file will saved and EMACS will halt.  A continue will
re-enter ^R mode.!

    F~Editor_Name..J*+fqEditor_Name+1"N
      f=..j(-1"g 0'
      [..J :I..J[..J_^R]_0:'
    M.M &_Recursive_^R_Set_Mode F[^R ENTER !* Turn off for recursive calls!
    F< !TOPLEVEL_^R!
      			    !* Enter ^R mode !
				    !* User types ^Z to quit !
      -1FO ..Q ^R_Exit_Flag @;     !* Zero value will really quit !
      1:<			    !* Errorset !
	FQMM_Quit "G MMM_Quit'  !* Execute special instructions !
        "#
	  QBuffer_Filenames"N
	      1M(M.M^R_Save_File)' !* Save file if appropriate !
	  QAuto_Save_Mode "N
	      QAuto_Save_Filename [ 1
	      :<ED1>		    !* Delete all versions of autosave file !
	      ] 1 '
	  FSXJNAME:F6[J
	  F~JSNDMSG"N		    !* SNDMSG prints its own message !
	      @FTGood-bye. '
	  ]J			    !* Restore temporary Q-reg !
	  100000.FSEXITW '	    !* Halt !
	> F"N FG'		    !* Report any errors !
      >				    !* Repeat indefinitely !
    @V
    FS ^R MODE"N FS ^R EXIT '	    !* Exit the ^R mode initially invoking!
    fs backdepth"n ' 	    !* This macro might be called directly!

!DM Secretary Macro:! !S Standard ..F:  Auto-save for use in ^R mode editing.
If QAuto Save Mode is  non-zero, the buffer is saved
(as by ^R Save File) after every FS ^R MDLY characters.!

    FS MODIFIED"E 0'		    !* Don't save buffer unless it has changed.!
    QAuto_Save_Mode"E 0'	    !* Is saving enabled for this buffer?!
    FSZ"E 0'			    !* Is there anything in the buffer?!
    FS ^R MODE"E 0'		    !* Are we leaving ^R mode? !

    @FT _(Auto_Save)
    1:< 2,M(M.M ^R_Save_File) >
    FS RGETTY"E F+'
    0

!^R Forward TECO Iteration:! !^R Move past the > matching the following <.!
    0[1 .[3
    .( :S
: FSZ-.F[VZ )J	    !* Don't look past end of this macro.!
    < :S<>!*;
      0A-< "E %1' !>!		    !* Count <'s and >'s.!
!<!   0A-> "E Q1-1U1 Q1-1"L 0''
      0A-* "E S!' >		    !* Ignore insides of comments.!
    Q3J FG 0

!^R Backward TECO Iteration:! !^R Move back past the < matching the preceding >.!
    0[1 [2 .[3
    .( -:S
: .F[VB )J	    !* Don't look past start of this macro.!
    < -:S<>!
;
      1A-< "E Q1-1U1 Q1-1"L 0'' !>!	    !* Count <'s and >'s.!
!<!   1A-> "E %1'
      1A-! "E .U2 -S!	    !* On finding <excl><cr>, look for the matching excl!
      		2A-*"N Q2J''	    !* And if it has a start after it, skip the whole thing!
      >
    Q3J FG 
