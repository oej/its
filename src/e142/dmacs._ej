@W
[0+8+FQ(+4)[1
0FO10F"G+Q1
'W+FQ()+4U1
FQ1"L0'
,Q1:M(Q1+4(]1]0))
  u	QwR:I:P:B:PPP
:[:b:0:7zDJDT:l:u(<(HRvSSKSVS,S7 r ~<<;^;iGQ*'*6((*E!E)K6KAIGIPjs@f@mAtA{;5;;*G*N6&6-/Y/`M M$66;I;P=='1D1K696?LNL]T&T0L\gpMYMdSiStn{LLIS'2JUjw6>PIPRagEBEJQ;QI&!U`how	u6u@u,u@>JuLuVuu U3UC|Q|]udupULUVll+	n	~
S
`o|grhx0x=ww&ccnhn{k\ko|l|w+7_X_c||(|6|@vdvmWCWLf;fEq8qBsgsqqgqqELsFsOv~w{K{XrSr]tSt]]|^^o_)>KV2VEYY
Q`O\]V]fm~]8]DZu[_&_4^O^_^,^7(4_D_M}-}8Y8YE)`i`u\W\g[][kT^ThTRTY& Setup DMACS LibraryM(M.MDatamedia)
Datamediai Q..$[0
640FSQVECTORU.X
2FS^RINITu..<
6FS^RINITu..>
M.M^R Backward Wordu..(
M.M^R Backward End-of-WordU:.X(()
M.M^R Forward WordU..)
M.M^R Forward End-of-WordU:.X())
M.M^R Beginning of Real Lineu..[
M.M^R Back to IndentationU:.X([)
M.M^R Prefix MetaU.]
M.M^R End of Real Lineu..]
M.M^R Up Real Lineu..^
Q0U...^
M.M^R Up Comment LineU:.X(^)
M.MDM Indent New LineuJ
M.M^R Down Real Lineu..J
M.M^R Indent New Comment LineU:.X(12.)
15.FS^RINITUM
16.FS^RINITu..M
M.M^R Down Comment LineU:.X(15.)
M.M^R Goto BeginningU..{
M.M^R Mark BeginningU:.X({)
M.M^R Goto EndU..}
M.M^R Mark EndU:.X(})
M.M^R Previous ScreenU..+
M.M^R Prefix Control-MetaU.\
M.M^R Next ScreenU..\
M.M^R Scroll Other WindowU:.X(\)
M.M^R Move to Screen EdgeU..|
M.M^R Reposition WindowU..~
M.M^R New WindowU..=
M.MDM Where Am IU:.X(=)
M.M^R Backward Kill Wordu..
M.M^R Backward Kill to End-of-WordU:.X()
377.FS^RINITU.._
Q..$U..._
Q..$U:.X(_)
11.FS^RINITUI
M.MDM Indent NestedU..I
M.M^R Indent RigidlyU:.X(9)
M.M^R Universal ArgumentU..*
M.M^R Indent for CommentU..;
M.M^R Set Comment ColumnU:.X(;)
M.M^R Move to HposU..:
M.M^R Set Hpos Target ColumnU:.X(:)
M.M^R Prefix MetaU
M.M^R Prefix Control-MetaU..
M.M^R Define Kbd MacroU../
M.M^R One WindowU:.X(1)
M.M^R Two WindowsU:.X(2)
M.M^R View Two WindowsU:.X(3)
M.M^R Modified Two WindowsU:.X(4)
Q0U.@
Q0U..@
Q0U...@
Q0U.A
M.M^R Append Next KillU..A
Q0U...A
Q0U.B
Q0U..B
Q0U...B
Q0U.C
M.M^R Center LineU..C
Q0U...C
M.M^R Center RegionU:.X(C)
Q0U.D
4FS^RINITu..D
M.M^R Kill Wordu...D
M.M^R Directory DisplayU:.X()
M.M^R Kill to End-of-WordU:.X(D)
Q0U.E
M.MDM Exchange CharactersU..E
M.MDM Exchange WordsU...E
M.M^R Exchange LinesU:.X(E)
M.M^R Edit FileU:.X()
Q0U.F
Q0U..F
Q0U...F
M.M^R Find FileU:.X()
M.M^R Goto Fixed MarkU..G
Q0U...G
Q0U
M.M^R Set Bounds RegionU..H
M.M^R Set Bounds FullU..
17.FS^RINITU..I
Q0U..J
Q0U.K
M.M^R Kill Lineu..K
M.M^R Kill Regionu...K
M.M^R Kill into Q-regU:.X(K)
12.FS^RINITU.L
M.M^R Lowercase Wordu..L
M.M^R Lowercase Regionu...L
M.M^R Set Fixed MarkU..M
M.M^R No-opU.N
M.M^R Un-killU..N
M.M^R Un-kill PopU...N
M.M^R Get Q-regU:.X(N)
Q0U.O
Q0U..O
M.M^R Complement Overwrite Modeu...O
M.M^R Other WindowU:.X(O)
Q0U.P
M.MGoto PageU..P
M.M^R Mark PageU...P
M.M^R Set Bounds PageU:.X(P)
M.M^R Quoted InsertU.Q
M.M^R Fill Paragraphu..Q
M.M^R Fill Regionu...Q
M.M^R Set Fill ColumnU:.X(Q)
M.M^R Do Not Write FileU:.X()
Q0U.R
M.MDM Reverse Character SearchU..R
M.MDM Reverse Incremental SearchU...R
M.MDM Query ReplaceU:.X(R)
M.M^R Read FileU:.X()
Q0U.S
M.MDM Character SearchU..S
M.MDM Incremental SearchU...S
M.M^R TECO SearchU:.X(S)
M.MDM Save FileU:.X()
Q0U.T
M.M^R Find TagU..T
Q0U...T
Q0U.U
M.M^R Uppercase Wordu..U
M.M^R Uppercase Regionu...U
M.M^R Uppercase InitialU:.X(U)
Q0U.V
Q0U..V
Q0U...V
M.M^R Visit FileU:.X()
M.M^R Backward Kill WordU.W
M.M^R Copy LineU..W
M.M^R Copy RegionU...W
M.M^R Put Q-regU:.X(W)
M.MWrite FileU:.X()
Q.XU..X
M.M^R Execute Completed MM CommandU...X
M.M^R Execute MinibufferU:.X(X)
Q0U.Y
M.MSelect BufferU..Y
M.MList BuffersU...Y
33.FS^RINITU.Z
M.M^R Zap to CharacterU..Z
M.M^R Zap thru CharacterU...Z
MMMake VariableFixed Mark
50FSQVECTORUFixed Mark
(@:I*/QMode[A
QAuto Fill Mode[B/)M.VBuffer Deselection Hook
(@:i*/M(M.M A Mode)
QBM.LAuto Fill Mode
QB"N1M.LSwitch Mode Process Options'
/)M.VBuffer Creation Hook
69fsadline
69ufill column
M.VCSearch Default
1M(M.MSet Variable Comment)Indentation Increment* Number of spaces per level of indentation
QComment ColumnM.VMoveto Column
(M.MDM Toplevel ^R)FS^RENTER
(M.MDM Secretary Macro)U..F
Q..FU.F
0M.VMM Quit
M(M.MText Mode)
@:I*/M.M^R Find TagU..T
m.m^R Add TagU:.X(T)/M.VTags Setup Hook
(M.M& Maybe Strip)M.VVisit File Hook
:IEditor NameDMACS
:I..JDMACS 
M(M.M& Set Mode Line)
0 ^R Complement Overwrite ModeiQOverwrite Mode[1
Q1"N0U1'"#-1U1'
Q1UOverwrite Mode
Q1FS^RREPLACE
M(M.M& Set Mode Line)
0
Goto Page!f[sstring[1
QPage Delimiter[0
u1ff"e1u1'
"#Q1"GJQ1-1U1''
q1"gq1<:s0;>'
"#Q1"LR'
-:S0:'
FF-1"G
.U1
:S0:.[2
Q1J-1L
Q2-."LQ2J''
0^R Copy Lines0.:
FF"EL'
"#L'
:M(M.M^R Copy Region)^R Set Fixed Mark)FF"E.:'
"#.U:Fixed Mark()'
0^R Goto Fixed MarkFFF"E.(W):'
"#"L.:WW1:<>'
"#.:
Q:Fixed Mark()J''
0^R Zap to Characterh.:
[0FF"E1U0'"#U0'
Q0"GC'"#R'
Q0M(M.MDM Character Search)
"LC'"#R'
:M(M.M^R Kill Region)^R Zap thru CharacterQ.:
[0FF"E1U0'"#U0'
Q0M(M.MDM Character Search)
:M(M.M^R Kill Region)^R Forward Word71:<1A"C1+'1.W:FWL>F"NFG0'
-1:<2.W:FWL>F"NFG'0^R Forward End-of-Word!f"LW-':<"L-'.wfwl>"nfg'0^R Backward End-of-Word91:<0A"C-1'-1.W:FWL>F"NFG0'
-1:<-2.W:FWL>F"NFG'0^R Kill WordX1[9.[0
1:<1A"C1+'1.W:FWL>F"NFG0'
-1:<2.W:FWL>F"NFG0'
Q0,.:M(M.M& Kill Text)^R Kill to End-of-Word([9.,(.wfwr).F:M(M.M& Kill Text)#^R Backward Kill to End-of-Word[-1[9.[0
1:<0A"C-1'-1.W:FWL>F"NFG0'
-1:<-2.W:FWL>F"NFG0'
.,Q0:M(M.M& Kill Text)^R Kill into Q-reg1:M(M.M^R Put Q-reg)^R No-op0DM Where Am IU:i*CFSECHODIS
QPage DelimiterU3
[E[BFSBOUNDUEUB
0,FSZFSBOUND
.U0J1U10U4<:S3;.-Q0-2;.U4%1>
Q4J1U2<L.-Q0-1;.-Z;%2>
Q0JQB,QEFSBOUND
@FTPage Q1@:=
@FT Line Q2@:=
@ft X=fsshpos@:=
@ft Y=fs^rvpos@:=
.-z"n@ft CH=8[..e1a@:=]..e'
@ft .=.@:=@ft(.*100/fsz@:=@ft%)
fsvz+b"n
@ft H=<h@:=@ft>'
@ft 1fsechoact0^R TECO SearchA1,M(M.M& Read Line)Search:[0
[1Q1"E1U1'
Q1:S0"EFG'
0DM Query Replace]FF"N:\'"#:I*'[1
1,M(M.M& Read Line)Query Replace:[0
1M(M.MQuery Replace)0
Grind SexpW1:<
FDLR
F[VBF[VZFLFSBOUND
F=MODELISP"NOConfirm'
z-b-1000"g!Confirm!^FTDo you really want to Grind this s-expression? (Y or N):
FI:FC-Y(FSEchoDisplayCFSEchoDisplay)"N''
Z:
M(M.M& Save Region and Query)
WJ
[2[3
[D128*5,32:ID
11.*5:FD-D:M2
15.*5:FDRK:M2
12.*5:FD-D:M2
%*5:FDC
"*5:FDR^FLL
(*5:FD:M3
!"!'*5:FD:M3
)*5:FDRM3C
:I2Z-.<1AF 	:;D>32I
:I3Z-.<1AF 	:;D>
HFD
J.(0FSVBW0L.FSVB)J
FSWIDTH-10[W
FSWIDTH*2/3[C
0FO..QFill ColumnF"NUW
QWUC'
-1FO..QComment Column+1F"G-1UC'
QC[M
-1FO..QMiser Column+1F"G-1UM'
[R:IR/8+1*8
0FO..QComment RoundingF"NUR'
M.M& Indent[I
[G^:IG`
[2S'R
1A-("N^FWL'
FL-.-QW++(FSHPOSU2Q2)"LFLL'
CQ2-QM"L
!"!1AF';()"L^FWL1A-32"EC'''
FSHPOSU2
!LP!1a-32"EDOLP'
1A-)"EC'
FSHPOSU3
Q3-Q2"N13I10I
Q2/8,9IQ2&7,32I'
+1MGOLP
`
0MG
J7F~(DEFUN "E
^FLL8F=
      "E
8D.U3L
Q3,.F~FEXPR
*(Q3,.F~MACRO
)"E
-2D6D'''
JHU2U3
>
JZ:
Q3,Q2DM Incremental Search7[D
0[L
10.[R
[Q@:iQ`
q4+1*5-fq3"e
q3[..ozj
200,0i]..o'
.u:3(%4)
qLu:3(%4)
q2u:3(%4)
q0u:3(%4)
qDu:3(%4)
`
[T@:iT`
fsrgetty"n3.&qR"n
fsechodispTfsechodisp
fsechodispLfsechodisp''
@ft8:i8
`
[0
[2:i2
[8:i8
1fo..qSearch Exit Option[E
200fsqvector[3
-1[4
[5
.[P
[S:ISM.M& Isearch RuboutUS:MS
1f[noquit
[6[7[..j
qD"g:i6I-Search  :i7Failing I-Search  '
qD"l:i6Reverse I-Search  :i7Failing Reverse I-Search  '
0[I
fsrgetty"n
fsechodispTfsechodisp
fsechodispLfsechodisp
@ftSearch: -1fstypeo'
"#@ft S: 1fstypeo'
!Restart!
1:<1uI-2f[noquit
<qL"eq6'"#q7'u..j
0@V1uI2,m.iw:fiu00uI@fiu5
q5-"efq2:@;!<!0;>0fsnoquitwqD:m(m.m^R String Search)'
q5-8"eoFunny'
q5-176."goFunny'
q5-
"e
FSREREAD'
!Normal!
4uR
mQ
:i220
fq8"nmt'
@ft0"#
!Try!
mt
1&qR"n!<!>'
'
qL"n!<!>'
.u5
40.&qR"e
qD"gfq2-1r'
"#fsz-qPf[vz
fq2-1"gfq2:c"ezj''
f]vz''
qD:s2"l!<!>'
q5j1uLfg!<!>
!Funny!
q5-177."eoRubout'
q5&137.-S"eQ5-600."LoForward''
q5&137.-R"eQ5-600."LoBackward''
q5&537.-Q"eoQuote'
qE"eonormal'
oControl
!Quote!
fsosteco"n-1f[helpch'
2,m.ifiu0
fsosteco"nf]helpmac'
onormal
!Forward!
qD"l:i6I-Search:i7Failing I-Search'
q4"LqD"goDefault'
"#1uD!<!>''
mQ
qD"L0uL'
1uD
40.uR
otry
!Backward!
qD"g:i6Reverse I-Search:i7Failing Reverse I-Search'
q4"LqD"loDefault'
"#-1uD!<!>''
mQ
qD"g0uL'
-1uD
40.uR
otry
!Default!
mQ
qSearch Default Ring[..o
.fswordu2]..o
fq2"l:i2'
q2u8
40.uR
otry
!Rubout!
q4"lfg!<!>'
ms
otry
!Control!
q5fsreread
0;
>>u0@feqit-q0"e@fg
QL"g<ms-ql;>mt
oRestart'
qI"emsmtoRestart'
QPJ0fsnoquit
-1fsquit''
q0f"nfserr'
fq2"g
qSearch Default Ring[..o
fq(.fsword)-1"G5c.-z"ej''
q2,.fsword
]..o'
@ft
qPmMM & Maybe Push Point
0!DM Reverse Incremental Search$-@:M(m.mDM Incremental Search)DM Character Search>[0[1[20[3[9
!RDCH!M.I@:FIU0
FIU9
Q0-(FS^RLAST)"EF[SSTRING
QCSearch DefaultFSSSTRING
OSEARCH'
Q0:FCU0
Q0-301."E
Q1:M(M.M^R String Search)'
Q0-306."E1u3oRDCH'
Q0-321."EM.IFIU9'
Q0-322."E-Q1U1ORDCH'
Q0-323."EF[SSTRING
QCSearch DefaultFSSSTRING
OSEARCH'
Q0-324."E'
"#F[SSTRING0S9'
FSSSTRINGuCSearch Default
!SEARCH!
.U0Q1:S"EFG'
Q0M(M.M& Maybe Push Point)
q3"N2fo..QNext Screen Context Lines:f'
1
DM Reverse Character Search"-@:M(m.mDM Character Search)
LISP Mode
M(M.M& Init Buffer Locals)
M.M^R Indent For LISPM.Q..	
M.M^R Mark SexpM.Q.@
M.M^R Mark DefunU:.X(@)
M.M^R Backward SexpM.Q.B
M.M^R Backward ListM.Q..B
M.M^R Backward Up ListM.Q...B
M.M^R Beginning of DefunU:.X(B)
M.M^R Kill SexpM.Q.D
M.MDM Exchange SexpsM.Q.E
M.M^R Forward SexpM.Q.F
M.M^R Forward ListM.Q..F
M.M^R Forward Up ListM.Q...F
M.M^R Make ()M.Q..V
M.M^R End of DefunU:.X(F)
1,(:I*(* )M.LComment Start
1,(:I*(* )M.LComment Begin
1,(:I*))M.LComment End
1,(:I*)M.LParagraph Delimiter
0FO..QLISP ..DF"E
S
!"!:I* A    A    A    A    A    A    A    A    A              A         
    A    A    A    A    A    A    A    A    A    A    A    A    A    A    A    A    A    A         A    |    A   AA   A/    A    '    (    )    A    A    A    A   AA    A   AA   AA   AA   AA   AA   AA   AA   AA   AA   AA    A    A    A    A    A    A    A   AA   AA   AA   AA   AA   AA   AA   AA   AA   AA   AA   AA   AA   AA   AA   AA   AA   AA   AA   AA   AA   AA   AA   AA   AA   AA    A    A    A    A    A    A   AA   AA   AA   AA   AA   AA   AA   AA   AA   AA   AA   AA   AA   AA   AA   AA   AA   AA   AA   AA   AA   AA   AA   AA   AA   AA    A    A    A    A        M.VLISP ..D
QLISP ..D'M.Q..D
Q.0,1M(M.M& Set Mode Line)LISPMIDAS ModeIM(M.M& Init Buffer Locals)
1,(:I*;)M.LComment Start
1,(:I*;)M.LComment Begin
1,(:I*)M.LParagraph Delimiter
0fo..qMIDAS Vector[1
q1"e5*5fsqvectoru1q1m.vMIDAS Vector
m.m^R Go to AC Fieldu:1(0)
m.m^R Kill Terminated Wordu:1(1)
m.m^R Go to Address Fieldu:1(2)
m.m^R Go to Next Labelu:1(3)
m.m^R Go to Previous Labelu:1(4)'
1,Q:1(0)M.Q..B
1,Q:1(2)M.Q..F
1,Q:1(3)M.Q...F
1,Q:1(4)M.Q...B
Q.0,1M(M.M& Set Mode Line)MACRO
TECO Mode	1,M.M& FILE PURIFY LOADED"E
F[DFILEM(M.MLoad Library)PURIFY'
M(M.M& Init Buffer Locals)
1,(:I*!*)M.LComment Start
1,(:I*!* )M.LComment Begin
1,(:I*!)M.LComment End
1,(:I*)M.LParagraph Delimiter
m.m^R Backward TECO ConditionalM.Q..B
m.m^R Forward TECO ConditionalM.Q..F
m.m^R Backward TECO IterationM.Q...B
m.m^R Forward TECO IterationM.Q...F
FSRGETTY"N
65FS^RINITM.Q['
0FO..QTECO ..DF"E
!"!:I*                                                                  
                                                                     A                             A    A    A    A    A    A    '    (    )    A    A         A    A    /   AA   AA   AA   AA   AA   AA   AA   AA   AA   AA    A    ;    A    A    A    A    A   AA   AA   AA   AA   AA   AA   AA   AA   AA   AA   AA   AA   AA   AA   AA   AA   AA   AA   AA   AA   AA   AA   AA   AA   AA   AA    A    A    A    A    A    A   AA   AA   AA   AA   AA   AA   AA   AA   AA   AA   AA   AA   AA   AA   AA   AA   AA   AA   AA   AA   AA   AA   AA   AA   AA   AA    A    |    A    A        M.VTECO ..D
QTECO ..D'M.Q..D
Q.0,1M(M.M& Set Mode Line)TECO
SAIL Mode'M(M.MLoad)SAIL
:M(M.MSAIL Mode)MACRO ModeF:M(M.MMIDAS Mode)
Text ModebM(M.M& Init Buffer Locals)
1,0M.LSpace Indent Flag
M.M^R Mark SentenceM.Q..@
M.M^R Mark ParagraphM.Q...@
M.M^R Backward SentenceM.Q..B
M.M^R Backward ParagraphM.Q...B
M.M^R Forward SentenceM.Q..F
M.M^R Forward ParagraphM.Q...F
0FO..QText ..DF"E
!"!:I*                                                                  
                                                                     A                             A    A    A    A    A    A   A'    (    )    A    A         A    A    /   AA   AA   AA   AA   AA   AA   AA   AA   AA   AA    A    ;    A    A    A    A    A   AA   AA   AA   AA   AA   AA   AA   AA   AA   AA   AA   AA   AA   AA   AA   AA   AA   AA   AA   AA   AA   AA   AA   AA   AA   AA    A    A    A    A    A    A   AA   AA   AA   AA   AA   AA   AA   AA   AA   AA   AA   AA   AA   AA   AA   AA   AA   AA   AA   AA   AA   AA   AA   AA   AA   AA    A    |    A    A        M.VText ..D
QText ..D'M.Q..D
Q.0,1M(M.M& Set Mode Line)Text& SAI Mode:M(M.MSAIL Mode)& LSP Mode& LISP Mode:M(M.MLISP Mode)& PUB Mode:M(M.MText Mode)Auto Fill Mode-1*(FF)"E1'"#0'UAuto Fill Mode
1M.LSwitch Mode Process Options
M(M.M& Process Options)
M(M.M& Set Mode Line)
0
Fill ModeF:M(M.MAuto Fill Mode)
Save ModeF:M(M.MAuto Save Mode)DM Indent New LineL@-F 	K
.(@MM
0fo..qFill Prefix[3
fq3"gg3'
"#0fFM..I'
),.DM Indent Nested[.4.[.2
100000[.3
QComment Start[.5
"G'"#1'<
<
0@l@-f
lb-.;
0@l@f 	r
fq.5f"gf~.5"e!<!>''
fsshposu.4
q.4"e!<!>'
q.4-q.3:;
>
q.4u.3>
fshposu.4
"L-*QIndentation Increment+Q.4U.4'
q.2jz-.u.2@0l
q.4m(m.m& indent)(
z-q.2,.fj)Startup Datamedia}^:I..L`
FSECHOLINES-3"G3FSECHOLINESW'
:M(M.MDM Toplevel ^R)
`
Q..9"EQ..LU..9'
FQ(0FO..QAuto Save Filenames)-1"L
FSMSNAME:F6[0
FSUINDEX+100000:\[1
:I*DSK:<0>AUTOSAVE..1M.VAuto Save Filenames]1]0'
FSXJNAME:F6[J
FSMSNAMEFSDSNAME
QFind File Inhibit WriteUInhibit Write
FS%TOFCI"E
M.M^R Autoarg[0460.-1[1
10<Q0,%1^FS^RCMAC>Q0U..-
]1]0'
0[00[1
Z"EFJJ@F
 K'
ZJ."N
0,0A-
"E-D'
J:S"N.,Z^FX1-D'
HFX0'
FSLISPT"NFSCCLFNAMU0
0FSSUPERIOR
0U1F~JSNDMSG"EM(M.MTEXT MODE)''
HK0FSMODIFIED
Q0"EQ1"E
0FO..QDMACS Version[1
Q1"EqEMACS Version:\U1'
FTDMACS Editor, version 1 - type ^_ (the "hold" key) for help.
]1
!''!''
FQ0-1"LQ1"NM1'
]1]0]J:M..9'
QInhibit Write,M(M.MVisit File)0
FSLISPT"NF~JSNDMSG"N
QBuffer FilenamesF[DFILE
0FSDVERS
FSDFILEUBuffer Filenames
M(M.M& Set Mode Line)
F]DFILE''
Q1"NM1'
]1]0]J:M..9Dump DMACSF[DFILE
1,M.M& FILE PURIFY LOADED"E
M(M.MLoad Library)PURIFY'
FSHSNAMEUN
1:<ER<N>DMACS.:EJ>"N
:INEMACS
ER<N>DMACS.:EJ'
FSIFVERSION:\UV
QVM.VDMACS Version
:I*<N>DMACS.:EJ.VM.VDMACS Library Filename
EC
M(M.MDump Environment)<N>DMACS.EXEDump TEACH@:i*|
fsrgetty"eft
How do you expect to learn a display editor on a printing terminal?
140000.FSEXIT'
:i..9
f[bbindi
M(M.MStartup Datamedia)
f]bbind
etdsk:teach-emacs.tutorial
fshsnamefsdsnamewfsdfileu0
q0uBuffer Filenames
q0u:.b(qBuffer Index+2)
m(m.m& Set Mode Line)
jsblank lines inserted here
0l:kfsheight-24<i
>j
0u..h:m..l
F+
|m.vMM & Startup DMACS
-1,m(m.mVisit File)<EMACS>DMACS.TEACH
m(m.mText Mode)
F[DFILE
1,M.M& FILE PURIFY LOADED"E
M(M.MLoad Library)PURIFY'
ER<EMACS>DMACS.:EJ
FSIFVERSION:\[0
:I*<EMACS>DMACS.:EJ.0M.VDMACS Library Filename
EC
M(M.MDump Environment)<EMACS>TEACH-DMACS.EXE& Startup DMACS0FO..QMM & Startup DMACS[0
Q0"NFQ0"G:M0''
FSHSNAMEU0
1:<ER<0>DMACS.INIT>"E
@YECM(HFX*)'
FSMSNAME[1
ET<1>FOO..0
:M(M.MStartup Datamedia)DM Save File3"E:M(m.m^R Save File)'
1:M(m.m^R Save File)^R Save Filey0FO..QDebug Save File"NSFORCE ERROR'
Q..F-Q.F"N0'
QAuto Save Mode[1
FSMODIFIED"E
FF&1"N
QAuto Save Count"N
Q1-2"E
-1FSMODIFIED''''
FSMODIFIED"E
@FT
(No changes need to be written)
0FSECHOACT'
QBuffer Filenames[0
1[2
Q1-2"EFF&1"E
QAuto Save FilenamesU0-1U2''
Q0"E"N'
:I*No filenames to save underFSERR'
"N3*FSZ-(2*QAuto Save Size)"L
-2"E@FT
(File has shrunk -- not auto-saving)0FSECHOACT'
0F[TYISOURCE
@FT
File has shrunk a lot.  Save anyway
@FG1M(M.M& Yes or No)"E0FSERR'''
Q0F[DFILE
Q2"G
FSDDEVICE-(F6DSK)"E
1:<ERFSIFCDATE[4EC
Q:.B(QBuffer Index+8)[3
Q4"NQ3"NQ4-Q3"N
FTThis file has been written on disk since you last read or wrote it.
Should I write it anyway
M(M.M& Yes or No)(FSwindow+b,zf0u..h)"E0''''>''
Q2,M(M.MWrite File)0
Q1"N
%Auto Save Count
FSDVERSIO"E
Q1-2"EFF&1"E1:<ED <!>!>
''
"#QAuto Save Count-QAuto Save Max"G
%Auto Save DeleteF"GFSDVERSIO
1:<ED>'''''
FF&1"N0UAuto Save Count'
0DM Toplevel ^RMF~Editor Name..J*+fqEditor Name+1"N
f=..j(-1"g0'
[..J:I..J[..J ^R] 0:'
M.M& Recursive ^R Set ModeF[^RENTER
F<!TOPLEVEL ^R!

-1FO..Q^R Exit Flag@;
1:<
FQMM Quit"GMMM Quit'
"#
F+
QBuffer Filenames"N
1M(M.M^R Save File)'
QAuto Save Mode"N
QAuto Save Filename[1
F[DFile
:<ED1>
F]DFile]1'
FSXJNAME:F6[J
F~JSNDMSG"N
@FTGood-bye.'
]J
100000.FSEXITW'
>F"NFG'
>
@V
FS^RMODE"NFS^REXIT'
fsbackdepth"n'DM Secretary MacroFSMODIFIED"E0'
QAuto Save Mode"E0'
FSZ"E0'
FS^RMODE"E0'
@FT (Auto Save)
1:<2,M(M.M^R Save File)>
FSRGETTY"EF+'
0^R Forward TECO Iterationu0[1.[3
.(:S
:FSZ-.F[VZ)J
<:S<>!*;
0A-<"E%1'!>!
!<!0A->"EQ1-1U1Q1-1"L0''
0A-*"ES!'>
Q3JFG0^R Backward TECO Iteration0[1[2.[3
.(-:S
:.F[VB)J
<-:S<>!
;
1A-<"EQ1-1U1Q1-1"L0''!>!
!<!1A->"E%1'
1A-!"E.U2-S!
2A-*"NQ2J''
>
Q3JFGPushj-1FO..Qforkcode+1"E
[..+[..,
M(M.MLoad Library)EFORK
]..,]..+
'
:M(M.M^R Invoke Inferior)^R Define Kbd Macroe-1FO..QLast Kbd Macro+1"E
[(Q:.X(())[(q:.x()))
[(q:.x(E))[(Q:.X(Q))
M(M.MLoad Library)KBDMAC
]:.X(Q)]:.X(E)
]:.x())]:.x(()
m.m^R Kbd Macro QueryU..?
M.M^R Call Last Kbd MacroU:.X(/)
0M.VDefining Kbd Macro
(@:I*/QDefining Kbd Macro"NI Defining'/)M.VSet Mode Line Hook
@:I..P/QDefining Kbd Macro"N
0UDefining Kbd Macro
M(M.M& Set Mode Line)'
..P/
'
QDefining Kbd Macro"E
M(M.M^R Start Kbd Macro)
1UDefining Kbd Macro
M(M.M& Set Mode Line)
0'
"#
M(M.M^R End Kbd Macro)[0
FF"EM(M.MName Kbd Macro)'
0UDefining Kbd Macro
M(M.M& Set Mode Line)
Q0'& Maybe StripSF~ModeTECO"E0'
.FSWORD&1"E
:S"E0''
:M(M.MStrip SOS Line Numbers)^R Move to HposQFF"E
QMoveto Column[0'
"#[0'
Q0"LFG0'
Q0UMoveto Column
0L
1:<0,Q0FM>"E0'
:LFSHPOS[1
Q1-Q0"L
.[2
Q0&770.-(Q1&770.)/8<9I>
Q0-FSHPOS<32I>
Q2,.'
<R
Q0-FSHPOS;>
.,(Q0-FSHPOS<32I>).^R Set Hpos Target Column\ff"n'"#fsshpos'f(uMoveto Column
):\[0
@ft
Hpos Target Column = 0 0fsechoact& DM Exchange Subrh[5[2[3[4
"G5R-5FX4
Z-.U2
-15L15FX3
.[0
G4Z-Q2JG3FKC
Q0,Z-Q2'
"L15R-15FX4
Z-.U2
5L-5FX3
.[0
G4Z-Q2JG3FKC
Q0,Z-Q2'
.,(w).fu2j
15R-15L.u0
q2j15R-15fx4z-.u2
q0j15fx3g4z-q2j.u2g3
q0q0,.(q2j)DM Exchange CharactersRff"e
@:f"e
0@f"n
-ai3rd2c.-2,.'''
:i*,:m(m.m& DM Exchange Subr)DM Exchange Words):i*.wfw,:m(m.m& DM Exchange Subr)DM Exchange Sexps':i*^fl,:m(m.m& DM Exchange Subr)^R Exchange Linesd.-Z"EFF"E
[2
-1A-13"E-FX2-L'
"#0:FX20:L'
.,(G2ZJ).''
:i*@F,:m(m.m& DM Exchange Subr)^R Center RegionE.,(W).F[2
Z-Q2U2:J
<1M(M.M^R Center Line)
.+Q2-Z;>
:,.~FILENAME~	DMACS~DOC~ ~FILENAME~Library to rearrange the command set for easy use from
SRI-style Datamedia keyboards.  Commands are summarized in the file
<EMACS>DMACS.CHART .

~DOC~ & Setup DMACS Library& Setup macro
~DOC~ Datamedia8C Set up the EMACS/Datamedia environment.
Rearranges the command set for easy use from SRI-style
Datamedia keyboards.  Commands are summarized in the file
<EMACS>DMACS.CHART .
&~DOC~ ^R Complement Overwrite Mode|
^R If Overwrite Mode is on, turn it off.  If it is off,
turn it on.  When Overwrite Mode is on, typed non-meta characters
will delete and overwrite characters in the buffer instead
of being inserted.  Meta characters still function normally.
~DOC~ Goto PagekC Move forward or back by pages, or to specific page.
If no arg, go to top of next page.
If arg is zero, go to top of present page.
If arg is negative, go to top of present page, unless already at top,
	in which case go to top of preceding page.
If arg is positive (+n), go to top of page n of buffer.
If two args (m,n), go to line m of page whatever.
~DOC~ ^R Copy LinesU^R Like killing lines and getting them back,
but doesn't mark buffer modified.
~DOC~ ^R Set Fixed Mark_^R Set either THE mark, or special fixed mark.
If no arg, set "ring-of-point" mark.
If arg is zero or positive, set corresponding fixed mark.
There are 10 fixed marks, numbered 0 to 9.  They contain character
counts relative to the beginning of the buffer.  Fixed marks may
be changed only by this macro, and are unaffected by killing, etc.
~DOC~ ^R Goto Fixed Mark4^R If no arg, exchange point and "ring-of-point" mark.
If negative arg, pop the "ring-of-point" mark.
If zero or positive arg, set "ring-of-point" mark and goto fixed mark.
~DOC~ ^R Zap to CharacterX^R Kills text up to but not including a
target character.  Uses the Character Search macro to obtain
the target character from the keyboard and search for it.  The search
skips over the character pointed to.

~DOC~ ^R Zap thru Character"^R Kills text up to and including a
target character.  Uses the Character Search macro to obtain
the target character from the keyboard and search for it.
~DOC~ ^R Forward Word$^R Move forward over one word.
 ~DOC~ ^R Forward End-of-Word+^R Move forward to the next word end.
!~DOC~ ^R Backward End-of-Word@^R Like Backward Word, but moves to end of
previous word.
~DOC~ ^R Kill Word0^R Kill next word and trailing delimiters.
 ~DOC~ ^R Kill to End-of-Word
^R Kill to next word end.
)~DOC~ ^R Backward Kill to End-of-WordE^R Like Backward Kill Word,
but kills to end of previous word.
~DOC~ ^R Kill into Q-reg ^R Put Q-reg and Kill text
~DOC~ ^R No-op^R Does nothing.
~DOC~ DM Where Am I^R Print various things about the cursor position.
Print the page and line,
the X position, the Y position,
the octal code for the following character,
cursor position in characters and as a percentage of the total file,
and the virtual boundaries, if any.
~DOC~ ^R TECO Search/^R Search, using the basic TECO string search facility.
Special characters:
^B matches any delimiter char.
^N matches any char other than the char following it in the search
	string (i.e., "not").  ^N^B matches non-delimiters, and
	^N^X matches nothing.  ^N^Q^B matches all but ^B, etc.
^O divides the string into substrings searched for simultaneously.
	Any one of these strings, if found, satisfies the search.
^Q quotes the following char, i.e., deprives it of special significance.
	Escape and rubout cannot be quoted.
^X matches any char.
~DOC~ DM Query ReplaceC
^R Replace string, asking about each occurrence.
Query Replace:FOOBAR displays the next FOO;  you say what to do.
Space => replace it with BAR and show next FOO.
Rubout => don't replace, but show next FOO.
Comma => replace this FOO and show result, waiting for next command.
Period => replace this FOO and exit.  Altmode => just exit.
^ => return to site of previous FOO (actually, jump to mark).
^W => kill this FOO and enter recursive ^R.
^R => enter ^R mode recursively.  ^L => redisplay screen.
Exclamation mark => replace all remaining FOOs without asking.
Any other character exits and is read again.
If QCase Replace is nonzero, BAR will be capitalized or all caps 
if FOO was.
1 MM Query ReplaceFOO... will replace only FOOs that are
bounded on both sides by delimiter characters (according to ..D).
~DOC~ Grind SexpZC Grind the sexp after the pointer.
A modification of the MIT Grind Sexp that recognizes that
in Interlisp, % quotes a character, " starts a long
string, and ; has no significance.
Uses QMiser Column to decide where to start using "Miser" format,
and QFill Column as the page width to aim for.
Saves the old sexp on the kill ring.

~DOC~ DM Incremental Search5^R Search for character string.
As characters are typed in, the accumulated string is
searched for.  Characters may be rubbed out.
^Q quotes special characters.
^S or M-S repeats the search forward; ^R or M-R repeats it backward.
If the accumulated string is empty, ^R, ^S, M-R or M-S either
reverses the direction of search or gobbles the previous
search string and searches for it again.
Altmode or any random control character exits
(anything but altmode is then executed).
If the accumulated string fails to be found,
you will be notified with one bell.  You can then exit,
rub the bad characters out (or ^G them all away),
or try searching in the opposite direction.
Quitting a successful search goes back to the starting
point of the search;  quitting a failing search rubs out
enough characters to make it successful again.
Altmode when the string is empty makes the search
non-incremental by calling ^R String Search.
'~DOC~ DM Reverse Incremental SearchZ^R Incremental Search Backwards.
Calls Incremental Search with a negative argument.
~DOC~ DM Character Search{^R Search backward for a single character.
Special Characters:
   ^A	Call ^R String Search; use MM Describe to see what that does.
   ^F	Position window so search object is near top
   ^Q	Quote following character
   ^R	Reverse search direction and read another char
   ^S	Search for default
        Also done if character macro is called by is typed again,
	overides any other function of that character shown here.
   ^T	Search for Teco default
If ^S is not used, the character typed becomes the default
for future searches.  Defaults are kept separate
from the regular TECO "S" command and from Incremental Search.
%~DOC~ DM Reverse Character Search{^R Search backward for a single character.
Special Characters:
   ^A	Call ^R String Search; use MM Describe to see what that does.
   ^F	Position window so search object is near top
   ^Q	Quote following character
   ^R	Reverse search direction and read another char
   ^S	Search for default
        Also done if character macro is called by is typed again,
	overides any other function of that character shown here.
   ^T	Search for Teco default
If ^S is not used, the character typed becomes the default
for future searches.  Defaults are kept separate
from the regular TECO "S" command and from Incremental Search.
~DOC~ LISP ModeKC Sets things up for editing LISP code
within the DMACS environment.
~DOC~ MIDAS ModeDC Set things up for editing MIDAS code.
M-F and M-B go to address and AC fields, respectively.
C-M-F and C-M-B go to next and previous label.
Paragraphs are delimited only by blank lines.
~DOC~ TECO ModeRC Set things up for editing TECO code.
Makes Rubout the Tab-hacking Rubout.
Loads the PURIFY library.  Makes comments be bounded by "!* " and "!".
M-F moves forward over a TECO conditional;  M-B, back.
~DOC~ SAIL Mode0C Sets things up for editing SAIL programs
~DOC~ MACRO ModeDC Set things up for editing MACRO code.
M-F and M-B go to address and AC fields, respectively.
C-M-F and C-M-B go to next and previous label.
Paragraphs are delimited only by blank lines.
~DOC~ Text ModesC Set things up for editing English text.
Makes Auto Fill not indent new lines;  says there are no comments.
~DOC~ & SAI ModeS Setup for SAIL.
~DOC~ & LSP Mode~DOC~ & LISP ModeS Setup for LISP.
~DOC~ & PUB ModeS Setup for Text mode.
~DOC~ Auto Fill ModehC Turn Auto Fill mode on or off.
No arg or argument of 1 turns the mode on;
any other arg turns it off.
When it is on, lines are broken at the right margin
(position controlled by QFill Column) at spaces,
by doing a LF.
~DOC~ Fill Mode!C Alias for Auto Fill Mode.
~DOC~ Save Mode!C Alias for Auto Save Mode.
~DOC~ DM Indent New Line^R Inserts CRLF, then indents the second line.
Any spaces before the inserted CRLF are deleted.
Uses the definitions of CR and Meta-Tab to do the work,
except that if there is a Fill Prefix it is used to indent.
An argument is passed on to the definition of Meta-Tab.
~DOC~ DM Indent Nested^R Indent line for specified nesting level.
With no argument (or argument 1) indents the line at the same nesting
level as the last nonblank line (ie, directly under it).
A larger argument means that this line is that many levels
closer to the surface, and should indent under the last line
above it whose level is the same.  The previous lines are scanned
under the assumption that any line less indented than its successors
is one level higher than they.
A negative arg N indents to the right of the previous nonblank line;
the amount of additional indentation is N times Q$Indentation Increment.
Unindented lines and comment lines are ignored.
If the cursor is not at the beginning of a line, the whole line
is indented, but the cursor stays fixed with respect to the text.
~DOC~ Startup DatamediaC Initialize for editing, process JCL and edit.
Intended to be called from the user init file, instead of reading
<EMACS>EMACS.INIT.
~DOC~ Dump DMACSC Write out DMACS.EXE
~DOC~ Dump TEACH"C Write out TEACH-DMACS.EXE 
~DOC~ & Startup DMACSS Startup after dumping.
~DOC~ DM Save Filel^R Save Buffer on Disk if Modified.
With zero arg, use Auto Save Filename,
else use Buffer Filename.
~DOC~ ^R Save Filee^R Save buffer on disk if modified.
Auto Save mode uses this macro.
If auto-saving is enabled, then we write to filenames read
or to a separate auto-save filename.  If auto-saving is off,
or if given an argument, we always write to the filenames read.
"1," as argument indicates that this call was not explicitly
requested, and the user should be asked to confirm if
the file has become a lot smaller.  "2," means an auto save,
which should abort if the file is shrunken.
~DOC~ DM Toplevel ^R"S Enter a loop entering ^R mode within a catch.
Useful as a toplevel macro to be assigned initially to FS ^R ENTER.
The macro MM Top Level will then pop up and into the outermost ^R.
If Q^R Exit Flag is zero, then ^Z will revert to the TECO command loop.
Otherwise if QMM Quit is a string, then it will be macroed.
Otherwise, the file will saved and EMACS will halt.  A continue will
re-enter ^R mode.
~DOC~ DM Secretary Macro.S Standard ..F:  Auto-save for use in ^R mode editing.
If QAuto Save Mode is  non-zero, the buffer is saved
(as by ^R Save File) after every FS ^R MDLY characters.
#~DOC~ ^R Forward TECO Iteration2^R Move past the > matching the following <.
$~DOC~ ^R Backward TECO Iteration7^R Move back past the < matching the preceding >.
~DOC~ PushC Invoke an inferior process.
Takes two arguments, both prompted for: First the name of a
variable to hold/get the handle from, and second the name of the
subsys to invoke.  The handle defaults to the last handle.
The subsys defaults to "handle".EXE on directory SYSTEM if the
handle is exec, SUBSYS if "handle".EXE exists there, and the
login directory otherwise.  If the handle refers to a previously
created
(but not killed) process then that process is continued.  
^R Kill Inferior destroys the process.
~DOC~ ^R Define Kbd Macro=C Begin defining keyboad macro.
Everything you type becomes part of the keyboard
macro as well as being executed.
Type this command a second time to end the definition.
A numeric argument n when you finish the definition means
re-execute the macro n-1 additional times immediately.
If you do not specify a numeric argument, you will be
prompted for a character to assign it to (type rubout
or return if you don't want it assigned).
~DOC~ & Maybe Strip<S Strip nulls and SOS line numbers from a file
if (1) Mode is not TECO, and (2) either the first word of the
file has bit 35 on or at least two consecutive nulls exist in the file.
~DOC~ ^R Move to HposF^R Move cursor to a given horizontal position,
adding tabs and spaces if needed.
With argument, move to that column number.
Without argument, move to the column whose number was last given.
#~DOC~ ^R Set Hpos Target Column^R Set target column for ^R Move to Hpos.
If argument is supplied, set target to that column.  If no arg,
set target to current horizontal position.
~DOC~ & DM Exchange SubrRS Subroutine used by exchange functions.
arg1 is a string which is "fw" for the appropriate chunk-type.  It will
always get an arg.  arg2 is the ^R-arg, see the documentation
of ^R Exchange Characters.
 ~DOC~ DM Exchange Charactersb^R Interchange the characters before and after the cursor.
With a positive argument it interchanges the character before
the cursor with the n characters after the cursor.
With a negative argument, it interchanges the character after
the cursor with the n characters before the cursor.
With a zero argument, it interchanges the characters at point and mark.
No argument is like an argument of 1, except at the end of a line
the previous two characters are interchanged.
~DOC~ DM Exchange Words-^R Interchange the words before and after the cursor.
With a positive argument it interchanges the word before
the cursor with the n words after the cursor.
With a negative argument, it interchanges the word after
the cursor with the n words before the cursor.
With a zero argument, it interchanges the words at point and mark.
No argument is like an argument of 1.
Leaves the cursor between the chunks interchanged.
~DOC~ DM Exchange Sexps]^R Interchange the S-expressions before and after the cursor.
With a positive argument it interchanges the S-expression before
the cursor with the n S-expressions after the cursor.
With a negative argument, it interchanges the S-expression after
the cursor with the n S-expressions before the cursor.
With a zero argument, it interchanges the S-expressions at point and mark.
No argument is like an argument of 1.
Leaves the cursor between the chunks interchanged.
~DOC~ ^R Exchange LinesD^R Interchange the lines before and after the cursor.
With a positive argument it interchanges the line before
the cursor with the n lines after the cursor.
With a negative argument, it interchanges the line after
the cursor with the n lines before the cursor.
With a zero argument, it interchanges the lines at point and mark.
No argument is like an argument of 1, except at the end of the buffer,
the previous two lines are interchanged.
~DOC~ ^R Center Region9^R Center all lines between the point and the mark.
~DIRECTORY~>& Setup DMACS Library
Datamedia
^R Complement Overwrite Mode
Goto Page
^R Copy Lines
^R Set Fixed Mark
^R Goto Fixed Mark
^R Zap to Character
^R Zap thru Character
^R Forward Word
^R Forward End-of-Word
^R Backward End-of-Word
^R Kill Word
^R Kill to End-of-Word
^R Backward Kill to End-of-Word
^R Kill into Q-reg
^R No-op
DM Where Am I
^R TECO Search
DM Query Replace
Grind Sexp
DM Incremental Search
DM Reverse Incremental Search
DM Character Search
DM Reverse Character Search
LISP Mode
MIDAS Mode
TECO Mode
SAIL Mode
MACRO Mode
Text Mode
& SAI Mode
& LSP Mode
& LISP Mode
& PUB Mode
Auto Fill Mode
Fill Mode
Save Mode
DM Indent New Line
DM Indent Nested
Startup Datamedia
Dump DMACS
Dump TEACH
& Startup DMACS
DM Save File
^R Save File
DM Toplevel ^R
DM Secretary Macro
^R Forward TECO Iteration
^R Backward TECO Iteration
Push
^R Define Kbd Macro
& Maybe Strip
^R Move to Hpos
^R Set Hpos Target Column
& DM Exchange Subr
DM Exchange Characters
DM Exchange Words
DM Exchange Sexps
^R Exchange Lines
^R Center Region
~INVERT~[1<Q1-1U1Q1FP;>Q1
