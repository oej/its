pW[0 +8+fq(+4)[1
0fo10 f"g +q1 '
+fq()+4u1
fq1"l 0'
,q1:m(q1+4(]1 ]0))]T^8H		mw3(32:c:u::n{ t ~5?-=)
))6)B)b)r!n!}1~2
22)/:/H11GR&y'%0&&alu$7+3m3z(](h8!8-(#(x5=5J#6p2N2\u!DRN`Te$g$v"I"W.:!/!>ijV)V6KKA[AdA8ADdd i.iCh/hB;o;YY*OON\NkA	A^F^U_#_2``Z4ZFb4bEbVbh`saazbG%G3\\ GjGx[k[{GGGUII==*MM)dBdR]|^
ff C'C<C4C<KcKyee%?
? @'@<b}c>@>OTaTsRqSPmQO+O@[$[6Z_ZpB1BAYRYd;D;N;8;?nOnU& Setup WORDAB LibraryQ[1[2
6*5fsQVectoru.e
m.m& WRDAB Mode or Global Expandu:.e(0)
m.m& Expandu:.e(1)
0u:.e(2)
0u:.e(3)
0u:.e(4)
0u:.e(5)
1,m.m& Setup Compressed WORDAB Librariesu1
q1"n fm1'
0fo..qWORDAB SETUP HOOKu1
q1"n m1'
m.m& WRDAB Set Mode Line Hooku1
0fo..qSet Mode Line Hooku2
q2"e q1'"# :i*21'm.vSet Mode Line Hookw
&Old Word Abbrev Character Describe}[0[1
 1,(:i*Type word abbrev key to describe: )m.i
@fiu0
q0fs^RCMacro-(m.m^R Abbrev Expand And Call Old Char)"n
    q0m(m.m& Charprint)
    ft does not run ^R Abbrev Expand And Call Old Char.  It runs
   q0fs^RCMacro :m(m.mDescribe)'
 8[..e q0:\u1 ]..e
qMM # WRDAB Old 1u1
ftAfter possibly expanding,  q0m(m.m& Charprint) ft runs 
 q1:m(m.mDescribe)    ^R Abbrev Expand OnlyB!^R Abbrev Expand !
.(
0,0a"c m:.e(0)'
)-."e ff"g fg'' 1&^R Abbrev Expand And Call Old Charu!^R Abbrev Expand !
 ff"E
0,0a"c m:.e(0)''
[.1 8[..e q..0fs^RIndirect:\u.1 ]..e
f @:mMM # WRDAB Old .1$^R Abbrev Expand And Self-InsertU!^R Abbrev Expand !
 ff"e 0,0a"c m:.e(0)''
 f@:m(q..0fs^RIndirectfs^Rinit)!& WRDAB Mode or Global Expand`-fwx*[.1 qMode[.2
:fo..qX .1 .2 Abbrevf"lw :fo..qX .1 * Abbrevf"lw''u.2
:m:.e(1)& Global Expand7-fwx*[.1
:fo..qX .1 * Abbrevf"lw'[.2
:m:.e(1)& Expand+[..0
q:..q(q.2+2)[.3
q.3fp-101"N :i:..q(q.2+2)1'
"# .(g.3)j .(\+1:\u:..q(q.2+2))j fq.3d'
-fq.1d
0,0a--"E
-1fo..qWord Abbrev Prefix Mark+1-."E
:i.1-.1
-d''
.u:.e(3)
.[.4
g:..q(q.2+1)
.[.5
-1[.7
fq.1[.8
<%.7-q.8;
q.7 :g.1"a0;'>
q.7 :g.1"u
q.4j :fwl
1 @fc
q.8-1 :g.1"u
0fo..qWordab All Caps"e
0u.3
:< 2:fwl .-q.5; %.3w
1 @fc >w
q.3"e q.4,q.5 @fc''
"#
q.4,q.5 @fc''
'
q.1u:.e(2)
:i:.e(5)
q.5j
q.4,q.5 f
ff-1"G oUPDATE '
0fo..qAuto Fill Mode"E  oUPDATE '
0fo..qFill Columnf"e w fsWidth-10'u.1
fsSHpos-q.1-2"l oUPDATE'
m.m^R Indent New Comment Line[I
q.5(:fx.5
)-q.4f<!OUT!
fsSHpos-q.1-2:;
<.-1,(0l.):fb "e f;OUT'
q.1-fsHpos;>
.-q.4"L .u:.e(3)
.,q.4x:.e(5)
.u.4'
@f k
:fx.3
@mIw
:0L.,(:2Lg.3).f>
:l .(g.5)j
!UPDATE!

 q.4,.x:.e(4)
^R Unexpand Last Word>z-.[.4
fn z-q.4j
q:.e(2)"e fg @ft
No last expansion 0fsEchoActivew 1 '
 q:.e(2)[.1
q:.e(4)[.3
0,1 :g.1 [.2
.2--"E
1,fq.1 :g.1 u.1'
"# :i.2'
q:.e(3)[.5
1:<q.5j>"N zj'
fq.3f~.3"n fg @ft
No last expansion 0fsEchoActivew 1 '
fq.3d
.,(g:.e(5)
g.2
g.1). f
:i*Fundamental fo..qMODEu.2
:fo..qX .1 .2 Abbrevf"G u.2'
"# :fo..qX .1 * Abbrevf"G u.2''
q:..q(q.2+2)[.3
.(g.3)j .(\-1:\u:..q(q.2+2))j fq.3d
1 Word Abbrev Mode
WORDAB= [.2[.3
 ff&1"E 1u.3'
"# "'N,0u.3'
q.3m.vWord Abbrev Modew
ff&2"n "n m.m& Global Expandu:.e(0)'
	      "# m.m& WRDAB Mode or Global Expandu:.e(0)''

 0fo..qWord Abbrev Hooku.2
q.2"N q.3 m.2'
q.3"E
q.2"E 0u:.x(U)
0u:.x()
0u:.x()
0u:.x(-)
0u:.x(+)'
m(m.m& Set Mode Line)
'
0fo..qWORDAB Ins Chars"E
:i*!~@#;$%^&*-_=+[]()\|:`"'{},<.>/? 
 m.vWORDAB Ins Charsw
:i* m.vWORDAB Old Charsw'
q.2"E
m.m^R Unexpand Last Word u:.x(U)
m.m^R Add Mode Word Abbrev u:.x()
m.m^R Inverse Add Mode Word Abbrev u:.x()
m.m^R Add Global Word Abbrev u:.x(+)
m.m^R Inverse Add Global Word Abbrev u:.x(-)
m.m^R Abbrev Expand Only u... w
m.m^R Word Abbrev Prefix Mark(!"!) u..'
ff&2"n q:.x()(q:.x(+)u:.x())u:.x(+)
q:.x()(q:.x(-)u:.x())u:.x(-)''
:m(m.m& Set Mode Line)Define Word Abbrevs[.1[.2[.4
 g(q..o(f[BBindw))
bj 0s <:s;ric>
zj i

bj
 < .-z;
   :s:; -d
0fx.1
@f 	k
0,1a-("E d :flfx.2 d'
"# :i.2*'
@f 	k
@f0123456789 fx.4
fq.4"E :i.40'
@f 	k
0,1a-34"N :i*No quote to start expansionfsErr
	     '
d i:i*
0s" !'! <:s"e :i*No quote to end expansionfsErr'
0,1a-":@; c> !'!
0,1a-15."n :i*Possible unquoted " in expansion -- final " not at end of linefsErr !''!'
   -d
iM.VX .1 .2 Abbrevw
i M.CX .1 .2 Abbrev.4
l>
j 0s"" <:s; -d>
m( hx* )
List Word Abbrevsr[.1 f[BBindw
m(m.mInsert Word Abbrevs)
 bj i
abbrev: (mode)  count   "expansion"


ht ft
Done.
  Insert Word Abbrevs	[1[2[3[4[5[6
 q..ou1
f[BBind q..ou6 [..o
:fo..qX u2
q2"L -q2u2'
q1u..o i

 -l
fq..q/5-q2/3(
q2-1u2
)< q:..Q(%2)u3
q:..Q(%2)u4
q:..Q(%2)u5
q4fp"L oNEXT'
f~(0,2:g3)X "N oNEXT'
f~(fq3-7,fq3:g3) Abbrev"N oNEXT'
2,fq3-7g3
-s d i:	
1a-*"E d'"# i( :l i)'
9i g5 i	" !'!
"f4:"l q6u..o g4
j 0s" <:s; i"> !''! hx4 q1u..o' !'!
g4 i"
	!'!
!NEXT! >
Make Word Abbrevr:i*( :i*( :i*[.3)[.2)[.1
fq.3"E qMODEu.3'
q.1,q.2 m(m.m& Check And Make Word Abbrev).3
w 1  & Check And Make Word Abbrev`:i*[2 [1 [3
q1[4 [5
fq1< 0,1:g4u5
5"b fg @ft
Break chars not allowed in abbrev 0fsEchoActivew 1 '
       1,fq4:g4u4>
m.m& Shorten String[S
0fo..qX 1 2 Abbrevu4
q4"N f=34"N FG
q4mSu4
@ftRedefine "1" from "4"?  !''''!
1m(m.m& Yes or No)"E @ftNot redefined.
0fsEchoActivew 1 ''
"# @ftAlready so defined.
0fsEchoActivew 1 ''
q3m.vX 1 2 Abbrevw
m.cX 1 2 Abbrev0
@:i*|m.m& Make Non-Usage Abbrev Variable[V
q..q[..o
| fo..qLately Changed Abbrevsu4
q3m(m.m& Teco Quote String)u3
@:i*|4
MVX 1 2 Abbrev30|(
    )m.vLately Changed Abbrevsw
&Write Incremental Word Abbrev File[1
 e[e\ fne^e] f[DFile 1f[FNamSyntax
etDSK: fsHSNamefsDSNamew etINCABS >
4,fIncremental Filef"e w'u1
f[BBind g(:i* fo..qLately Changed Abbrevs)
z"e :i*No incremental abbrevs to write fsErr'
eihpef1
er fsIFileu1 ec @ft
Written: 1
 0fsEchoActivew 1%Read Incremental Word Abbrev FileJ[1 f[DFile
e[ fne] f[DFile 1f[FNamSyntax
etDSK: fsHSNamefsDSNamew etINCABS >
4,fIncremental word abbrev filef"e w'u1
et1
f[BBindw er @y
m( hx*f(m.vLately Changed Abbrevsw) )
& Teco Quote String3f[BBind g()
bm(m.m& Teco Quote Area)
hx* & Teco Quote Area).-z(
< .,:fb; ir >
)+zj #^R Inverse Add Mode Word AbbrevQqMode[.4
 .-z[.0
-:fwl
-fwx*[.1
1,m(m.m& Read Line)Expansion for .4 abbrev ".1": [.2 !''!
q.2"e 1'
fq.2"e 1'
m(m.mMake Word Abbrev).1.2
@m(m.m^R Abbrev Expand Only)f
q.0+zj
1%^R Inverse Add Global Word AbbrevH.-z[.0
-:fwl
-fwx*[.1
1,m(m.m& Read Line)Expansion for global abbrev ".1": [.2 !''!
q.2"e 1'
fq.2"e 1'
m(m.mMake Word Abbrev).1.2*
@m(m.m^R Abbrev Expand Only)f
q.0+zj
1^R Add Mode Word Abbrev"L f @:m(m.m^R Kill Mode Word Abbrev) '
:i*FUNDAMENTAL fo..qMODE [.1
f @m(m.m& Add Word Abbrev).1.1 Abbrev
w 1 ^R Add Global Word Abbreve"L f @:m(m.m^R Kill Global Word Abbrev) '
f @m(m.m& Add Word Abbrev)*Global Abbrev
w 1 & Add Word Abbrev+:i* [.2
[.3[.4[.5.[.6 fnq.6j
1:<fs^RMark+1f"G-1 u.3 1;'
"E .(:f(j)u.3)j 1;'
"N -fwl .u.3 fwl 1;'
>"N FG F*w 1 '
Q.3,. fx.3
m.m& Shorten String[S
m.m& Read Line[R
q.3mSu.4
1,mR for ".4": [.1 !''!
q.1"E 1 '
q.1,q.3 m(m.m& Check And Make Word Abbrev).2
1 

 0fo..qAbbrev Auto Save Mode"N
0fo..qAbbrev Auto Save Count+1u.4
q.4-(20fo..qAbbrev Auto Save Delay)"G
0m.vAbbrev Auto Save Countw
	@ft
(Abbrev Auto Save) m(m.mWrite Word Abbrev File)
0fsEchoActive
'"# q.4m.vAbbrev Auto Save Countw''
 1 & Shorten Stringb[.3[.4[.5
fq.3-40"G
0,16:g.3u.4
fq.3-16,fq.3:g.3u.5
:i.4.4.....5'
"# q.3u.4'
q.4 ^R Word Abbrev Prefix Marka!^R Abbrev Expand !
 ff"E
0,0a"c m:.e(0)''
. m.vWord Abbrev Prefix Markw
 .,(i-). 
& WRDAB Set Mode Line Hook+0(fsQPPtr[Q
)[.0
m(m.m& WRDAB Process Options Hook)
0fo..qWord Abbrev Mode"N
q.0"E :i.0 Abbrev'"# :i.0.0 Abbrev''
q.0( qQfsQPUnwindw
)^R Kill Mode Word Abbrev
:i*Fundamental fo..qMODE[.2
1, m(m.m& Read Line)Kill .2 Abbrev: [.1
q.1"E '
0fo..qX .1 .2 Abbrev"E
0fo..qX .1 * Abbrev"E
FG @ft".1" is neither .2 mode nor global abbrev. !''!
	0fsEchoActivew 1 '
"# FG @ft".1" is not a .2 mode abbrev, but is a global abbrev.
Kill it? !''!
	  1m(m.m& Yes Or No)"E
@ft Not killed.  0fsEchoActivew 1 '
:i.2*''
m(m.mKill Variable)X .1 .2 Abbrev
:i* fo..qLately Changed Abbrevsu.4
@:i*|.4
m(m.mKill Variable)X .1 .2 Abbrev| m.vLately Changed Abbrevsw
w 1 ^R Kill Global Word Abbrev61, m(m.m& Read Line)Kill Global Abbrev: [.1
q.1"E '
0fo..qX .1 * Abbrev"E
FG @ft".1" is not a global abbrev.
0fsEchoActivew 1  !''! '
m(m.mKill Variable)X .1 * Abbrev
:i* fo..qLately Changed Abbrevsu.4
@:i*|.4
m(m.mKill Variable)X .1 * Abbrev| m.vLately Changed Abbrevsw
w 1 Kill All Word Abbrevs8[.1[.2[.3
 q..q[..o zj
:f<!DONE! 15r
1<
0,2:g(.fsWord)u.3
f~.3X f"N "L f;DONE'
1;'
.fsWordu.3
.+5fsWordu.2
q.2fp:;
fq.3-7,fq.3 :g.3 u.3
f~.3 Abbrev"E 15d'
>
>
Edit Word Abbrevs3@:i*| 1m.vAbort Edit Word Abbrevsw
fs^RExitw |[.G
0m.vAbort Edit Word Abbrevsw
f[BBind
m(m.mInsert Word Abbrevs) bj
:i*Edit Word Abbrevs[..J

fsEchoDisw CfsEchoDisw
0fo..qAbort Edit Word Abbrevs"E
m(m.mKill All Word Abbrevs)
m(m.mDefine Word Abbrevs)
@ftWord abbrevs redefined.
0fsEchoActivew
'
"# FG @ftWord abbrevs NOT redefined.
0fsEchoActivew'
m(m.mKill Variable)Abort Edit Word Abbrevs
Sort Word AbbrevsEbj < .-z;
.-(:l)."E k'"# l'>
: 
:s"$f"Lw
-fwl \'!'!
l
& WRDAB Off PO Check@-1[.4[.5
< %.4-fq.1;
q.4:g.1u.5
q.5-q.6"E q.5m.7' >
& WRDAB On PO Check@-1[.4[.5
< %.4-fq.1;
q.4:g.1u.5
q.5-q.6"N q.5m.7' >
 & WRDAB Process Options Hook[.0[.1[.6[.7[.8
 0fo..qMM ^R Abbrev Expand for Tabf"EoRST'u.0
0fo..qWord Abbrev Mode"N
qI-q.0"n
qIm(m(m.m& Global or Local)I)MM # WRDAB Old 11
q.0uI'
0fo..qMM & WRDAB On PO Checkf"EoRST'u.0
0fo..qMM & WRDAB Turn On Ins Charf"EoRST'u.7
0fo..qMM & WRDAB Turn On Old Charf"EoRST'u.8
'
"# qI-q.0"E
qMM # WRDAB Old 11uI'
0fo..qMM & WRDAB Off PO Checkf"EoRST'u.0
0fo..qMM & WRDAB Turn Off Ins Charf"EoRST'u.7
0fo..qMM & WRDAB Turn Off Old Charf"EoRST'u.8
'
0fo..qWORDAB Ins Charsu.1
q.1"E :i.1'
0fo..qMM ^R Abbrev Expand And Self-Insertf"EoRST'u.6
m.0
0fo..qWORDAB Old Charsu.1
q.1"E :i.1'
0fo..qMM ^R Abbrev Expand And Call Old Charf"EoRST'u.6
q.8u.7
m.0

!RST!
m.m& WRDAB Process Options Hookm.vMM & WRDAB Process Options Hookw
 m.m^R Abbrev Expand for Tabm.vMM ^R Abbrev Expand for Tabw
 m.m& WRDAB On PO Checkm.vMM & WRDAB On PO Checkw
 m.m& WRDAB Turn On Ins Charm.vMM & WRDAB Turn On Ins Charw
 m.m& WRDAB Turn On Old Charm.vMM & WRDAB Turn On Old Charw
 m.m& WRDAB Off PO Checkm.vMM & WRDAB Off PO Checkw
 m.m& WRDAB Turn Off Ins Charm.vMM & WRDAB Turn Off Ins Charw
 m.m& WRDAB Turn Off Old Charm.vMM & WRDAB Turn Off Old Charw
 m.m^R Abbrev Expand And Self-Insertm.vMM ^R Abbrev Expand And Self-Insertw
 m.m^R Abbrev Expand And Call Old Charm.vMM ^R Abbrev Expand And Call Old Charw

f:m(m.m& WRDAB Process Options Hook)
& WRDAB Turn On Ins Char[.0
q.0[.4
q.4fp"L
m.m^R Abbrev Expand And Self-Insertu.0
'
f~.4!^R Abbrev Expand -19"e '
qWORDAB Ins Chars[.1
f.1[.2
0,q.2:g.1[.3
q.2+1,fq.1:g.1u.1
:iWORDAB Ins Chars.3.1
qWORDAB Old Charsu.1
:i.2
:iWORDAB Old Chars.1.2
m.m^R Abbrev Expand And Call Old Charu.0
[.6 8[..e :\u.6 ]..e
q.4m(m(m.m& Global or Local).0)MM # WRDAB Old .6
& WRDAB Turn On Old Char@[.0
q.0[.1
q.1fp"G
f~.1!^R Abbrev Expand -19"E
''
m.m^R Abbrev Expand And Call Old Charu.0
[.6 8[..e :\u.6 ]..e
q.1m(m(m.m& Global or Local).0)MM # WRDAB Old .6
& WRDAB Turn Off Ins Char[.0
fs^RInitu.0 & WRDAB Turn Off Old CharJ[.6 8[..e :\u.6 ]..e
0fo..qMM # WRDAB Old .6[.1
[.2
q.1u.2 ^R Abbrev Expand for Tab!^R Abbrev Expand !
 0,0a[.1
.,.f
f@mMM # WRDAB Old 11f
0,0a"B q.1"C
ff"E
-@f	 k
0,0a"c m:.e(0)'
f @mMM # WRDAB Old 11f'''
1& Global or Localv[1[2[3[9
[ -1:fsQPHome(]*w)u3
qBuffer Indexu9 q9+8u2
q:.b(q9)-9/2u1
q1< q:.b(%2)-q3"e q.L ' %2w >
q.V Read Word Abbrev Filef[DFile 1f[FnamSyntax
0fo..qLast Word Abbrev Filef"n fsDFilew'
"#w etDSK:WORDAB DEFNS fsHSnamefsDSnamew'
4,fWord Abbrev Filef"ew'fsDFilew
fsDFilem.vLast Word Abbrev Filew
f[BBind er @y
10f~m.m& Make "n
fsDFile[1
m(m.mRun Library)WABCONConvert Old Word Abbrev File1
er @y hx*m.vQWABL Definitionsw
'
hx* m.vQWABL Definitionsw
mQWABL definitions Write Word Abbrev File/[.0[.1[.2[.3[.4[.5 f[DFile
1f[FnamSyntax
0fo..qLast Word Abbrev Filef"n fsDFilew'
 "#w etDSK:WORDAB DEFNS fsHSnamefsDSnamew'
 4,fWord Abbrev Filef"ew'u.0
et.0 fsDFileu.0
q.0m.vLast Word Abbrev Filew
f[BBind
m.m& Teco Quote Area[Q
:fo..qX u.2
q.2"L -q.2u.2'
ff&1"E
^i|m.m& Make Usage Abbrev Variable[V
|'"#
^i|m.m& Make Non-Usage Abbrev Variable[V
|'
 iq..q[..o

 fq..q/5-q.2/3(
q.2-1u.2
)< q:..Q(%.2)u.3
q:..Q(%.2)u.4
q:..Q(%.2)u.5
q.4fp"L oNEXT'
f~(0,2:g.3)X "N oNEXT'
f~(fq.3-7,fq.3:g.3) Abbrev"N oNEXT'
iMV.3
.(g.4)mQ i
ff&1"E g.5 i'
i

     !NEXT! >
hx* m.vQWABL Definitionsw
1,m(m.m Write File).0
Word Abbrev Apropos.:i*[0[1
f[BBindw
0fo..qQWABL Definitionsu1
q1"n g1 j 2:k'
0fo..qLately Changed Abbrevsu1
q1"n .(g1)j 2:k'
j <:s
m(m.mKill Variable)X ; 2r .,(:lr).x1
0lk fsZ-.fsVZw
j<:s
MV1; 0l .,(3s).k>
0fsVZw >
bj <:s
MVX ; 

  >
bj l
 < :s0;
-s

 fkc .,(fwl).t ft:	
c 0,1a-*"N
ft( .,(s Abbrev fkc).t ft)'
ft	"!'!
s Abbrev
.,(sr).t
ft"
  !'!
:s

; >
ftDone.

  & Make Usage Abbrev Variable
:i*[.1
:i*[.2
:i*[.0
:FO..Q.1[.3
Q.3"L -Q.3*5J 15,0I 15R q.1,.FSWORDW 0,.+10FSWORDW
-Q.3U.3'
q.3+1*5j q.2,.fswordw
5c q.0,.fswordw $& Make Non-Usage Abbrev Variable:i*[.1
:i*[.2
:FO..Q.1[.3
Q.3"L -Q.3*5J 15,0I 15R q.1,.FSWORDW 0,.+10FSWORDW
-Q.3U.3'
q.3+1*5j q.2,.fswordw

~FILENAME~
WORDAB~DOC~ ~FILENAME~CWord Abbrev Mode package.  Documentation in INFO under EMACS.
 ~DOC~ & Setup WORDAB Library*S Run when WORDAB is loaded.  Calls a hook.
Calls WORDAB SETUP HOOK, if it exists.  That can do things like
    auto-loading a file of abbreviations.
Then appends & WRDAB Set Mode Line Hook to Set Mode Line Hook.
    Thus, anything put on those hook variables should not return by ^\.
,~DOC~ Old Word Abbrev Character Describe+C Tell what char does after expanding.
This command will ask you to type a character, e.g. Space, which runs the
word abbrev expander and then calls the old definition for that
character.  The description for that old definition will be given, e.g. 
the description for ^R Auto-Fill Space.

~DOC~ ^R Abbrev Expand Onlyv^R Expand last word, but insert nothing after it.
If given an argument, will feep if last word isn't an abbrev.
,~DOC~ ^R Abbrev Expand And Call Old Char
^R Expand last word, then run old char.
The "old" function run by the character after the expansion check may be
    described by MM Old Word Abbrev Character Describe which will ask you to
    type the character to describe.
Explicit ARG inhibits expanding.
*~DOC~ ^R Abbrev Expand And Self-InsertS Expand last word if an abbrev.
Giving an explicit numeric argument inhibits expansion, just inserting that
    many copies of char that ran this.
'~DOC~ & WRDAB Mode or Global Expand6S Expand previous word if mode or global abbrev.
~DOC~ & Global Expand.S Expand previous word if global abbrev.
~DOC~ & ExpandS .1 is abbrev, .2 is ..Q offset
A pre-comma ARG inhibits auto-filling.  (Since ^^M, e.g. is called by
    some to insert CRLF but not auto-fill.)

~DOC~ ^R Unexpand Last WordL^R Undo last expansion, leaving the abbrev.
If there was a prefix that was glued onto the expansion, it will be separated
    from the abbrev by a hyphen.
The abbrev's usage-count is decremented.
~DOC~ Word Abbrev Mode~DOC~ WORDABRC Mode for expanding word-abbrevs.
No arg or non-zero arg sets the mode, Word Abbrev Mode.
0 arg clears the mode.
Runs Word Abbrev Hook if any, with arg of new mode setting.  If none,
  the following keys are set:
    ^X ^A runs ^R Add Mode Word Abbrev,
    ^X ^H runs ^R Inverse Add Mode Word Abbrev,
    ^X +  runs ^R Add Global Word Abbrev,
    ^X -  runs ^R Inverse Add Global Word Abbrev,
    M-'   runs ^R Word Abbrev Prefix Mark,
    C-M-Space runs ^R Abbrev Expand Only, and
    ^XU   runs ^R Unexpand Last Word.
Giving this command 1 as a pre-comma argument means that you only use global
    abbrevs, and things are set up to be faster (e.g. faster expansion
      checking since it doesn't have to check both global and local abbrevs).
Each of the following chars:
    ~@#;$%^&*()-_=+[]\|:'`"{},<.>/?!, Space, Return,
will run ^R Abbrev Expand And Self-Insert, or ^R Abbrev Expand And Call Old
    Char.
Tab runs ^R Abbrev Expand for Tab.
~DOC~ Define Word Abbrevs(C Define word abbrevs from buffer.
~DOC~ List Word Abbrevs*C List abbrevs and their expansions.
~DOC~ Insert Word AbbrevsC Insert abbrevs defined and their expansions.
Format is acceptable to MM Define Word Abbrevs.
In particular, any double-quotes (the '"' character) in an expansion will be
    quoted with another double-quote.  E.g. HE SAID "HELLO" becomes HE SAID
    ""HELLO"".
~DOC~ Make Word AbbrevfC Make first string argument expand to second one.
After doing MM Make Word Abbrevfoofind outer otter, typing "foo" will
    automatically expand to "find outer otter".
3rd string argument, if any, is the mode for the abbrev.
No 3rd string argument means use the current mode.
3rd string argument = "*" means this make a global abbrev.
This command defines just one abbrev, as compared to Define Word
    Abbrevs which defines several abbrevs from a list in the buffer.
&~DOC~ & Check And Make Word Abbrev
S ARG1 abbrev, ARG2 expn, string arg mode.
String argument is "*" or space-modename, e.g. " TECO".
Checks for break characters in abbrev (not allowed).
,~DOC~ Write Incremental Word Abbrev File5C Write file of changed abbrevs.
Writes to file given by string argument.
(This does not reset the default filename for Write Word Abbrev File and
 Read Word Abbrev File.  I'm not sure of the correctness of this, though.)
Defaults to home directory, INCABS >.
See Read Incremental Word Abbrev File.
+~DOC~ Read Incremental Word Abbrev FilefC Load some abbrevs that changed.
String argument is filename that contains incremental abbrev definitions,
    e.g. written by Write Incremental Word Abbrev File.
    Default is home directory, INCABS >.
(This does not reset the default filename for Write Word Abbrev File and
 Read Word Abbrev File.  I'm not sure of this, but it seems correct.)
~DOC~ & Teco Quote String9S Takes string as NUMARG, returns with ^]^]s, ^]s.
~DOC~ & Teco Quote Area-S Quote altmodes and ^]s in ARG1,point.
)~DOC~ ^R Inverse Add Mode Word AbbrevZ^R Define expansion for word before point.
Numeric argument n means nth word before point is to be an abbrev (e.g.
    you thought it already was, and you are now n words beyond).
    No numeric argument means the word just before point, same as argument
    of 1.
Reads a one-line expansion for the abbrev, defines it, and expands it.
+~DOC~ ^R Inverse Add Global Word Abbrev]^R Define expansion for word before point.
Numeric argument n means nth word before point is to be an abbrev (e.g.
    you thought it already was, and you are now n words beyond).
    No numeric argument means the word just before point, same as argument
    of 1.
Calls & Read Line to get the expansion for that abbrev.  (No multi-line.)
Defines that abbrev, and then expands the abbrev before point.
Aborts if & Read Line is aborted, or if the expansion is null.
!~DOC~ ^R Add Mode Word Abbrev@^R Reads mode abbrev for words before point.
Negative ARG means to delete the word abbrev.  (If there is no such mode
    abbrev, but there is a global, it asks if it should kill the global.)
Positive ARG (>0) means expansion is last ARG words.
Zero ARG means expansion is between point and MARK.
If FS ^R Mark set, then for any ARG expansion between . and FS ^RMark.
The abbrev is only effective when in the current mode (e.g. LISP).
#~DOC~ ^R Add Global Word Abbrevl^R Reads global abbrev for words before point.
Negative ARG means to delete the word abbrev,
    calls ^R Kill Global Word Abbrev.
Positive ARG (>0) means expansion is last ARG words.
Zero ARG means expansion is between point and MARK.
If FS ^R Mark set, then for any ARG expansion between . and FS ^RMark.
The abbrev is effective in all major modes.
~DOC~ & Add Word AbbrevMS Reads an abbrev for words before point.
Stringarg1 is "*" for global abbrev, and space-modename for a mode abbrev,
    e.g. " TECO".
Stringarg2 is & Read Line prompt.
Calls & Read Line to read the abbrev.
ARG non-0 means expansion is last ARG words.  (Includes breaks in between
    words, but not those before first or after last word.)
ARG 0 means expansion is between point and MARK.
If FS ^R Mark set, then for any ARG expansion between . and FS ^RMark.
If the abbrev is already defined, user is asked if redefinition wanted.
The abbrev must not contain any break characters.
Abbrev variable is constructed: X abbreviation <mode/*> Abbrev.  It
    contains a string which is the expansion.
~DOC~ & Shorten StringPS Produce a short string, showing beginning/end.
ARG is a string pointer.
$~DOC~ ^R Word Abbrev Prefix Mark!^R Mark point as end of a prefix.
Expansion of the prefix may occur unless an ARG is given.
Sets Word Abbrev Prefix Mark to point and inserts a hyphen.
$~DOC~ & WRDAB Set Mode Line Hook2S Tell & Set Mode Line if display " Abbrev".
"~DOC~ ^R Kill Mode Word Abbrevg^R Causes mode abbrev typed to be expunged.
Same as ^R Add Mode Word Abbrev with a negative ARG.
$~DOC~ ^R Kill Global Word Abbrevk^R Causes global abbrev typed to be expunged.
Same as ^R Add Global Word Abbrev with a negative ARG.

~DOC~ Kill All Word Abbrevs/C No word abbrevs are defined after this.
~DOC~ Edit Word Abbrevs9C Go into ^R mode, editing word abbrev definitions.
Note that any '"'s are doubled so that the syntax is unambiguous.  E.g.
    if the abbrev 'xsay' is to expand to 'He said "Hello"', then it will be:
    xsay: 	1	"He said ""Hello"""
^R mode is entered.  When exited normally, (e.g. by ^C^C) the buffer will
    be considered as new definitions of word abbrevs.
^G will abort MM Edit Word Abbrevs, leaving word abbrevs untouched.
~DOC~ Sort Word AbbrevsxC Sort a word abbrev list in the buffer by count.
The most-frequently used abbrevs appear at the top of the list.
~DOC~ & WRDAB Off PO CheckS Check list of chars for expanders, fix.
q.1:    List of characters.
q.6:    ^R Macro to check against.
q.7:    Subroutine to call if char runs .6.
~DOC~ & WRDAB On PO Check$S Check list of expand characters for changes and fix.
q.1:    List of characters.
q.6:    ^R Macro to check against.
q.7:    Subroutine to call if change.
&~DOC~ & WRDAB Process Options Hook9S Check for characters to change.
Calls a subroutine to see-if/do any expand characters need updating.
Is a little slow for someone who makes Word Abbrev Mode local.  Could fix.
"~DOC~ & WRDAB Turn On Ins CharlS Make a ^R Abbrev Expand And Self-Insert key.
ARG: 9-bit of key to use.
If is FS^RInit, then becomes expand-ins.
Otherwise becomes a call-old expander, and character is moved from WORDAB
    Ins Chars to WORDAB Old Chars.
"~DOC~ & WRDAB Turn On Old CharQS Make a ^R Abbrev Expand And Call Old Char key.
ARG: 9-bit of key to use.
#~DOC~ & WRDAB Turn Off Ins Char"S Reset char ARG to builtin.
#~DOC~ & WRDAB Turn Off Old Char*S Reset char ARG to what was before.
"~DOC~ ^R Abbrev Expand for Tab	^R Expands abbrevs when Tab inserts at point.
If Tab will not insert any whitespace at point, no expansion is attempted.
    (E.g. the Tab is reindenting the line, but point is mid-line.)
Old Tab is in MM # WRDAB Old 11.
Explicit ARG inhibits expanding.
~DOC~ & Global or LocalES Return Q.L if argument is a local q-register.  Q.V otherwise.

~DOC~ Read Word Abbrev FileC Define word abbrevs from a file of definitions.
Stringarg is word abbrev definition file.  Default is <homedir>;WORDAB DEFNS.
 ~DOC~ Write Word Abbrev FileZC Write a definition file for all defined abbrevs.
Stringarg filename.  Default is WORDAB DEFNS.
Argument present means do not write out usage counts.
Default filenames come from last definition filename used.
~DOC~ Word Abbrev AproposC List abbrevs or expansions containing stringarg.
String argument is some pattern to find, either in abbrev, modename, or
    expansion.  It is a standard Teco search string;  e.g. you can do:
    MM Word Abbrev Apropos$foo^Obar$ which will match foo OR bar.
Currently this command only works "approximately" -- it may miss definitions
    that have changed via Edit Word Abbrevs, or were only defined by Define
    Word Abbrevs.  It will however catch all definitions read in from a file
    or defined one by one by the user.
&~DOC~ & Make Usage Abbrev VariableXS Like .V and .C combined, for speed.
STRARG1 is abbrev variable name.
STRARG2 is abbrev expansion with altmodes, ^]s quoted with ^]s.
STRARG3 is usage-count string.
Assumes ..Q is selected as buffer (..O).
*~DOC~ & Make Non-Usage Abbrev VariableyS Like .V and .C combined, for speed.
STRARG1 is abbrev variable name string.
STRARG2 is abbrev expansion string.
~DIRECTORY~	& Setup WORDAB Library
Old Word Abbrev Character Describe
^R Abbrev Expand Only
^R Abbrev Expand And Call Old Char
^R Abbrev Expand And Self-Insert
& WRDAB Mode or Global Expand
& Global Expand
& Expand
^R Unexpand Last Word
Word Abbrev Mode
WORDAB
Define Word Abbrevs
List Word Abbrevs
Insert Word Abbrevs
Make Word Abbrev
& Check And Make Word Abbrev
Write Incremental Word Abbrev File
Read Incremental Word Abbrev File
& Teco Quote String
& Teco Quote Area
^R Inverse Add Mode Word Abbrev
^R Inverse Add Global Word Abbrev
^R Add Mode Word Abbrev
^R Add Global Word Abbrev
& Add Word Abbrev
& Shorten String
^R Word Abbrev Prefix Mark
& WRDAB Set Mode Line Hook
^R Kill Mode Word Abbrev
^R Kill Global Word Abbrev
Kill All Word Abbrevs
Edit Word Abbrevs
Sort Word Abbrevs
& WRDAB Off PO Check
& WRDAB On PO Check
& WRDAB Process Options Hook
& WRDAB Turn On Ins Char
& WRDAB Turn On Old Char
& WRDAB Turn Off Ins Char
& WRDAB Turn Off Old Char
^R Abbrev Expand for Tab
& Global or Local
Read Word Abbrev File
Write Word Abbrev File
Word Abbrev Apropos
& Make Usage Abbrev Variable
& Make Non-Usage Abbrev Variable
~INVERT~[1 <Q1-1U1 Q1FP;> Q1
