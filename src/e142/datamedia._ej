W
[0+8+FQ(+4)[1
0FO10F"G+Q1
'W+FQ()+4U1
FQ1"L0'
,Q1:M(Q1+4(]1]0))
  %	HmHwMYMeJ)J4I1I=8 8(88(8289HH%88RaGEGR8D8Mkq'^'i   9=9G99hr)H)X';'L?Q?YE[EfCwD28!()i)o0U0\.x.KZKc.^.d:K:V0g0n4t4{LDLM-;,>FsGIOI\m}	=p=|JmJwF*F9ktHSkvW_	?r?z)4IgIr?H6Bv|z}O]}U}do)o3o
o3o?oI|N|Zo	oOO/|#|3oWocO8OBf
facarqoq|pWpe\}]
hYhleMe`vJvUzfzty	yYIYTQ1Q:`,`6k)k3lhlrk|l0<kZkdu
umTm]nFnPWmW}X`Xt{u|~0~@P P3RpR{u]ul6CWGWW{K{\W)W5TcTqYY%X@XPXX(Y5Y>wwS&S3~o~}ZZZfVGVVUKUYNFNPN8N?	/	5& Setup DATAMEDIA LibraryM(M.MDatamedia)
Datamediax
Q..$[0
640FSQVECTORU.X
2FS^RINITu..<
6FS^RINITu..>
M.M^R Backward Wordu..(
M.M^R Backward End-of-WordU:.X(()
M.M^R Forward WordU..)
M.M^R Forward End-of-WordU:.X())
M.M^R Beginning of Real Lineu..[
M.M^R Back to IndentationU:.X([)
M.M^R Prefix MetaU.]
M.M^R End of Real Lineu..]
M.M^R Up Real Lineu..^
M.M^R Up Comment LineU:.X(^)
M.MDM Indent New LineuJ
M.M^R Down Real Lineu..J
M.M^R Indent New Comment LineU:.X(12.)
15.FS^RINITUM
16.FS^RINITu..M
M.M^R Down Comment LineU:.X(15.)
M.M^R Goto BeginningU..{
M.M^R Mark BeginningU:.X({)
M.M^R Goto EndU..}
M.M^R Mark EndU:.X(})
M.M^R Previous ScreenU..+
M.M^R Prefix Control-MetaU.\
M.M^R Next ScreenU..\
M.M^R Move to Screen EdgeU..|
M.M^R Reposition WindowU..~
M.M^R New WindowU..=
M.MDM Where Am IU:.X(=)
M.M^R Backward Kill Wordu..
M.M^R Backward Kill to End-of-WordU:.X()
11.FS^RINITUI
M.MDM Indent NestedU..I
M.M^R Indent RigidlyU:.X(9)
M.M^R Universal ArgumentU..*
M.M^R Indent for CommentU..;
M.M^R Set Comment ColumnU:.X(;)
M.M^R Prefix MetaU
M.M^R Prefix Control-MetaU..
M.M^R Define Kbd MacroU../
M.M^R Call Last Kbd MacroU:.X(/)
M.M^R One WindowU:.X(1)
M.M^R Two WindowsU:.X(2)
M.M^R View Two WindowsU:.X(3)
M.M^R Modified Two WindowsU:.X(4)
Q0U.@
M.M^R Mark SentenceU..@
M.M^R Mark ParagraphU...@
Q0U.A
M.M^R Append Next KillU..A
Q0U...A
Q0U.B
M.M^R Backward SentenceU..B
M.M^R Backward ParagraphU...B
Q0U.C
M.M^R Center LineU..C
Q0U...C
Q0U.D
4FS^RINITu..D
M.M^R Kill Wordu...D
M.M^R Directory DisplayU:.X()
M.M^R Kill to End-of-WordU:.X(D)
Q0U.E
M.M^R Exchange CharactersU..E
M.M^R Exchange WordsU...E
M.M^R Edit FileU:.X()
Q0U.F
M.M^R Forward SentenceU..F
M.M^R Forward ParagraphU...F
M.M^R Find FileU:.X()
M.M^R Goto Fixed MarkU..G
Q0U...G
Q0U
M.M^R Set Bounds RegionU..H
M.M^R Set Bounds FullU..
17.FS^RINITU..I
Q0U..J
Q0U.K
M.M^R Kill Lineu..K
M.M^R Kill Regionu...K
M.M^R Kill into Q-regU:.X(K)
12.FS^RINITU.L
M.M^R Lowercase Wordu..L
M.M^R Lowercase Regionu...L
M.M^R Set Fixed MarkU..M
M.M^R No-opU.N
M.M^R Un-killU..N
M.M^R Un-kill PopU...N
M.M^R Get Q-regU:.X(N)
Q0U.O
Q0U..O
M.M^R Complement Overwrite Modeu...O
M.M^R Other WindowU:.X(O)
Q0U.P
M.MGoto PageU..P
M.M^R Mark PageU...P
M.M^R Set Bounds PageU:.X(P)
M.M^R Quoted InsertU.Q
M.M^R Fill Paragraphu..Q
M.M^R Fill Regionu...Q
M.M^R Set Fill ColumnU:.X(Q)
M.M^R Do Not Write FileU:.X()
Q0U.R
M.MDM Reverse Character SearchU..R
M.MDM Reverse Incremental SearchU...R
M.MDM Query ReplaceU:.X(R)
M.M^R Read FileU:.X()
Q0U.S
M.MDM Character SearchU..S
M.MDM Incremental SearchU...S
M.M^R TECO SearchU:.X(S)
M.MDM Save FileU:.X()
Q0U.T
Q0U..T
Q0U...T
Q0U.U
M.M^R Uppercase Wordu..U
M.M^R Uppercase Regionu...U
M.M^R Uppercase InitialU:.X(U)
Q0U.V
Q0U..V
Q0U...V
M.M^R Visit FileU:.X()
M.M^R Backward Kill WordU.W
M.M^R Copy LineU..W
M.M^R Copy RegionU...W
M.M^R Put Q-regU:.X(W)
M.MWrite FileU:.X()
Q.XU..X
M.M^R Execute Completed MM CommandU...X
M.M^R Execute MinibufferU:.X(X)
Q0U.Y
M.MSelect BufferU..Y
M.MList BuffersU...Y
33.FS^RINITU.Z
M.M^R Zap to CharacterU..Z
M.M^R Zap thru CharacterU...Z
MMMake VariableFixed Mark
50FSQVECTORUFixed Mark
(@:I*/QMode[A
QAuto Fill Mode[B/)M.VBuffer Deselection Hook
(@:i*/M(M.M A Mode)
QBM.LAuto Fill Mode
QB"N1M.LSwitch Mode Process Options'
/)M.VBuffer Creation Hook
M.VCSearch Default
0M.VDefining Kbd Macro
:i*m.vLast Kbd Macro
20.*5fsqvectoru..m
q..m[..ohk]..o
(@:I*/QDefining Kbd Macro"N
I Defining'/)M.VSet Mode Line Hook
1M(M.MSet Variable Comment)Indentation Increment* Number of spaces per level of indentation
(M.MDM Toplevel ^R)FS^RENTER
(M.MDM Secretary Macro)U..F
Q..FU.F
:IEditor NameEMACS/Datamedia
:I..JEMACS/Datamedia 
M(M.M& Set Mode Line)
0 ^R Complement Overwrite ModeiQOverwrite Mode[1
Q1"N0U1'"#-1U1'
Q1UOverwrite Mode
Q1FS^RREPLACE
M(M.M& Set Mode Line)
0
Goto Page!f[sstring[1
QPage Delimiter[0
u1ff"e1u1'
"#Q1"GJQ1-1U1''
q1"gq1<:s0;>'
"#Q1"LR'
-:S0:'
FF-1"G
.U1
:S0:.[2
Q1J-1L
Q2-."LQ2J''
0^R Copy Lines0.:
FF"EL'
"#L'
:M(M.M^R Copy Region)^R Set Fixed Mark)FF"E.:'
"#.U:Fixed Mark()'
0^R Goto Fixed MarkFFF"E.(W):'
"#"L.:WW1:<>'
"#.:
Q:Fixed Mark()J''
0^R Zap to Characterh.:
[0FF"E1U0'"#U0'
Q0"GC'"#R'
Q0M(M.M^R Character Search)
"LC'"#R'
:M(M.M^R Kill Region)^R Zap thru CharacterQ.:
[0FF"E1U0'"#U0'
Q0M(M.M^R Character Search)
:M(M.M^R Kill Region)^R Forward Word71:<1A"C1+'1.W:FWL>F"NFG0'
-1:<2.W:FWL>F"NFG'0^R Forward End-of-Word!f"LW-':<"L-'.wfwl>"nfg'0^R Backward End-of-Word91:<0A"C-1'-1.W:FWL>F"NFG0'
-1:<-2.W:FWL>F"NFG'0^R Kill WordX1[9.[0
1:<1A"C1+'1.W:FWL>F"NFG0'
-1:<2.W:FWL>F"NFG0'
Q0,.:M(M.M& Kill Text)^R Kill to End-of-Word([9.,(.wfwr).F:M(M.M& Kill Text)#^R Backward Kill to End-of-Word[-1[9.[0
1:<0A"C-1'-1.W:FWL>F"NFG0'
-1:<-2.W:FWL>F"NFG0'
.,Q0:M(M.M& Kill Text)^R Kill into Q-reg1:M(M.M^R Put Q-reg)^R No-op0DM Where Am IU:i*CFSECHODIS
QPage DelimiterU3
[E[BFSBOUNDUEUB
0,FSZFSBOUND
.U0J1U10U4<:S3;.-Q0-2;.U4%1>
Q4J1U2<L.-Q0-1;.-Z;%2>
Q0JQB,QEFSBOUND
@FTPage Q1@:=
@FT Line Q2@:=
@ft X=fsshpos@:=
@ft Y=fs^rvpos@:=
.-z"n@ft CH=8[..e1a@:=]..e'
@ft .=.@:=@ft(.*100/fsz@:=@ft%)
fsvz+b"n
@ft H=<h@:=@ft>'
@ft 1fsechoact0^R TECO SearchA1,M(M.M& Read Line)Search:[0
[1Q1"E1U1'
Q1:S0"EFG'
0DM Query Replace]FF"N:\'"#:I*'[1
1,M(M.M& Read Line)Query Replace:[0
1M(M.MQuery Replace)0
Grind SexpW1:<
FDLR
F[VBF[VZFLFSBOUND
F=MODELISP"NOConfirm'
z-b-1000"g!Confirm!^FTDo you really want to Grind this s-expression? (Y or N):
FI:FC-Y(FSEchoDisplayCFSEchoDisplay)"N''
Z:
M(M.M& Save Region and Query)
WJ
[2[3
[D128*5,32:ID
11.*5:FD-D:M2
15.*5:FDRK:M2
12.*5:FD-D:M2
%*5:FDC
"*5:FDR^FLL
(*5:FD:M3
!"!'*5:FD:M3
)*5:FDRM3C
:I2Z-.<1AF 	:;D>32I
:I3Z-.<1AF 	:;D>
HFD
J.(0FSVBW0L.FSVB)J
FSWIDTH-10[W
FSWIDTH*2/3[C
0FO..QFill ColumnF"NUW
QWUC'
-1FO..QComment Column+1F"G-1UC'
QC[M
-1FO..QMiser Column+1F"G-1UM'
[R:IR/8+1*8
0FO..QComment RoundingF"NUR'
M.M& Indent[I
[G^:IG`
[2S'R
1A-("N^FWL'
FL-.-QW++(FSHPOSU2Q2)"LFLL'
CQ2-QM"L
!"!1AF';()"L^FWL1A-32"EC'''
FSHPOSU2
!LP!1a-32"EDOLP'
1A-)"EC'
FSHPOSU3
Q3-Q2"N13I10I
Q2/8,9IQ2&7,32I'
+1MGOLP
`
0MG
J7F~(DEFUN "E
^FLL8F=
      "E
8D.U3L
Q3,.F~FEXPR
*(Q3,.F~MACRO
)"E
-2D6D'''
JHU2U3
>
JZ:
Q3,Q2DM Incremental Search7[D
0[L
10.[R
[Q@:iQ`
q4+1*5-fq3"e
q3[..ozj
200,0i]..o'
.u:3(%4)
qLu:3(%4)
q2u:3(%4)
q0u:3(%4)
qDu:3(%4)
`
[T@:iT`
fsrgetty"n3.&qR"n
fsechodispTfsechodisp
fsechodispLfsechodisp''
@ft8:i8
`
[0
[2:i2
[8:i8
1fo..qSearch Exit Option[E
200fsqvector[3
-1[4
[5
.[P
[S:ISM.M& Isearch RuboutUS:MS
1f[noquit
[6[7[..j
qD"g:i6I-Search  :i7Failing I-Search  '
qD"l:i6Reverse I-Search  :i7Failing Reverse I-Search  '
0[I
fsrgetty"n
fsechodispTfsechodisp
fsechodispLfsechodisp
@ftSearch: -1fstypeo'
"#@ft S: 1fstypeo'
!Restart!
1:<1uI-2f[noquit
<qL"eq6'"#q7'u..j
0@V1uI2,m.iw:fiu00uI@fiu5
q5-"efq2:@;!<!0;>0fsnoquitwqD:m(m.m^R String Search)'
q5-8"eoFunny'
q5-176."goFunny'
q5-
"e
FSREREAD'
!Normal!
4uR
mQ
:i220
fq8"nmt'
@ft0"#
!Try!
mt
1&qR"n!<!>'
'
qL"n!<!>'
.u5
40.&qR"e
qD"gfq2-1r'
"#fsz-qPf[vz
fq2-1"gfq2:c"ezj''
f]vz''
qD:s2"l!<!>'
q5j1uLfg!<!>
!Funny!
q5-177."eoRubout'
q5&137.-S"eQ5-600."LoForward''
q5&137.-R"eQ5-600."LoBackward''
q5&537.-Q"eoQuote'
qE"eonormal'
oControl
!Quote!
fsosteco"n-1f[helpch'
2,m.ifiu0
fsosteco"nf]helpmac'
onormal
!Forward!
qD"l:i6I-Search:i7Failing I-Search'
q4"LqD"goDefault'
"#1uD!<!>''
mQ
qD"L0uL'
1uD
40.uR
otry
!Backward!
qD"g:i6Reverse I-Search:i7Failing Reverse I-Search'
q4"LqD"loDefault'
"#-1uD!<!>''
mQ
qD"g0uL'
-1uD
40.uR
otry
!Default!
mQ
qSearch Default Ring[..o
.fswordu2]..o
fq2"l:i2'
q2u8
40.uR
otry
!Rubout!
q4"lfg!<!>'
ms
otry
!Control!
q5fsreread
0;
>>u0@feqit-q0"e@fg
QL"g<ms-ql;>mt
oRestart'
qI"emsmtoRestart'
QPJ0fsnoquit
-1fsquit''
q0f"nfserr'
fq2"g
qSearch Default Ring[..o
fq(.fsword)-1"G5c.-z"ej''
q2,.fsword
]..o'
@ft
qPmMM & Maybe Push Point
0!DM Reverse Incremental Search$-@:M(m.mDM Incremental Search)DM Character Search>[0[1[20[3[9
!RDCH!M.I@:FIU0
FIU9
Q0-(FS^RLAST)"EF[SSTRING
QCSearch DefaultFSSSTRING
OSEARCH'
Q0:FCU0
Q0-301."E
Q1:M(M.M^R String Search)'
Q0-306."E1u3oRDCH'
Q0-321."EM.IFIU9'
Q0-322."E-Q1U1ORDCH'
Q0-323."EF[SSTRING
QCSearch DefaultFSSSTRING
OSEARCH'
Q0-324."E'
"#F[SSTRING0S9'
FSSSTRINGuCSearch Default
!SEARCH!
.U0Q1:S"EFG'
Q0M(M.M& Maybe Push Point)
q3"N2fo..QNext Screen Context Lines:f'
1
DM Reverse Character Search"-@:M(m.mDM Character Search)
LISP Mode]	M(M.M& Init Buffer Locals)
M.M^R Indent For LISPM.Q..	
M.M^R Mark SexpM.Q.@
M.M^R Mark DefunU:.X(@)
M.M^R Backward SexpM.Q.B
M.M^R Backward ListM.Q..B
M.M^R Backward Up ListM.Q...B
M.M^R Beginning of DefunU:.X(B)
M.M^R Kill SexpM.Q.D
M.M^R Exchange SexpsM.Q.E
M.M^R Forward SexpM.Q.F
M.M^R Forward ListM.Q..F
M.M^R Forward Up ListM.Q...F
M.M^R End of DefunU:.X(F)
1,(:I*(* )M.LComment Start
1,(:I*))M.LComment End
1,(:I*)M.LParagraph Delimiter
0FO..QLISP ..DF"E
!"!:I* A    A    A    A    A    A    A    A    A              A         
    A    A    A    A    A    A    A    A    A    A    A    A    A    A    A    A    A    A         A    |    A   AA   A/    A    '    (    )    A    A    A    A   AA    A   AA   AA   AA   AA   AA   AA   AA   AA   AA   AA    A    A    A    A    A    A    A   AA   AA   AA   AA   AA   AA   AA   AA   AA   AA   AA   AA   AA   AA   AA   AA   AA   AA   AA   AA   AA   AA   AA   AA   AA   AA    A    A    A    A    A    A   AA   AA   AA   AA   AA   AA   AA   AA   AA   AA   AA   AA   AA   AA   AA   AA   AA   AA   AA   AA   AA   AA   AA   AA   AA   AA    A    A    A    A        M.VLISP ..D
QLISP ..D'M.Q..D
Q.0,1M(M.M& Set Mode Line)LISP
SAIL Mode'M(M.MLoad)SAIL
:M(M.MSAIL Mode)MIDAS Mode-M(M.M& Init Buffer Locals)
1,(:I*;)M.LComment Start
1,(:I*)M.LParagraph Delimiter
0fo..qMIDAS Vector[1
q1"e5*5fsqvectoru1q1m.vMIDAS Vector
m.m^R Go to AC Fieldu:1(0)
m.m^R Kill Terminated Wordu:1(1)
m.m^R Go to Address Fieldu:1(2)
m.m^R Go to Next Labelu:1(3)
m.m^R Go to Previous Labelu:1(4)'
1,Q:1(0)M.Q..B
1,Q:1(2)M.Q..F
1,Q:1(3)M.Q...F
1,Q:1(4)M.Q...B
Q.0,1M(M.M& Set Mode Line)MACROMACRO Mode:M(M.MMIDAS Mode)
TECO Mode
M(M.M& Init Buffer Locals)
1,(:I*!* )M.LComment Start
1,(:I*!)M.LComment End
1,(:I*)M.LParagraph Delimiter
1,Q(1,Q.M.Q)M.Q.
1,M.M& FILE PURIFY LOADED"E
F[DFILEM(M.MLoad Library)PURIFY'
m.m^R Backward TECO ConditionalM.Q..B
m.m^R Forward TECO ConditionalM.Q..F
0FO..QTECO ..DF"E
!"!:I*                                                                  
                                                                     A                             A    A    A    A    A    A    '    (    )    A    A         A    A    /   AA   AA   AA   AA   AA   AA   AA   AA   AA   AA    A    ;    A    A    A    A    A   AA   AA   AA   AA   AA   AA   AA   AA   AA   AA   AA   AA   AA   AA   AA   AA   AA   AA   AA   AA   AA   AA   AA   AA   AA   AA    A    A    A    A    A    A   AA   AA   AA   AA   AA   AA   AA   AA   AA   AA   AA   AA   AA   AA   AA   AA   AA   AA   AA   AA   AA   AA   AA   AA   AA   AA    A    |    A    A        M.VTECO ..D
QTECO ..D'M.Q..D
Q.0,1M(M.M& Set Mode Line)TECO
Text ModeM(M.M& Init Buffer Locals)
1,0M.LSpace Indent Flag
0FO..QText ..DF"E
!"!:I*                                                                  
                                                                     A                             A    A    A    A    A    A   A'    (    )    A    A         A    A    /   AA   AA   AA   AA   AA   AA   AA   AA   AA   AA    A    ;    A    A    A    A    A   AA   AA   AA   AA   AA   AA   AA   AA   AA   AA   AA   AA   AA   AA   AA   AA   AA   AA   AA   AA   AA   AA   AA   AA   AA   AA    A    A    A    A    A    A   AA   AA   AA   AA   AA   AA   AA   AA   AA   AA   AA   AA   AA   AA   AA   AA   AA   AA   AA   AA   AA   AA   AA   AA   AA   AA    A    |    A    A        M.VText ..D
QText ..D'M.Q..D
Q.0,1M(M.M& Set Mode Line)Text& SAI Mode:M(M.MSAIL Mode)& LSP Mode& LISP Mode:M(M.MLISP Mode)& PUB Mode:M(M.MText Mode)Auto Fill Mode-1*(FF)"E1'"#0'UAuto Fill Mode
1M.LSwitch Mode Process Options
M(M.M& Process Options)
M(M.M& Set Mode Line)
0DM Indent New LineL@-F 	K
.(@MM
0fo..qFill Prefix[3
fq3"gg3'
"#0fFM..I'
),.DM Indent Nested[.4.[.2
100000[.3
QComment Start[.5
"G'"#1'<
<
0@l@-f
lb-.;
0@l@f 	r
fq.5f"gf~.5"e!<!>''
fsshposu.4
q.4"e!<!>'
q.4-q.3:;
>
q.4u.3>
fshposu.4
"L-*QIndentation Increment+Q.4U.4'
q.2jz-.u.2@0l
q.4m(m.m& indent)(
z-q.2,.fj)Startup Datamedia5^:I..L`
FSECHOLINES-3"G3FSECHOLINESW'
:M(M.MDM Toplevel ^R)
`
Q..9"EQ..LU..9'
FQ(0FO..QAuto Save Filenames)-1"L
FSMSNAME:F6[0
FSUINDEX+100000:\[1
:I*DSK:<0>AUTOSAVE..1M.VAuto Save Filenames]1]0'
:FO..QMM Quit"LM.VMM Quit'
FSXJNAME:F6[J
FSMSNAMEFSDSNAME
QFind File Inhibit WriteUInhibit Write
0[00[1
Z"EFJ'ZJ
."N
0,0A-
"E-D'
J:S"N.,Z^FX1-D'
HFX0'
FSLISPT"NFSCCLFNAMU0
0FSSUPERIOR
0U1F~JSNDMSG"EM(M.MTEXT MODE)''
HK0FSMODIFIED
Q0"EQ1"E
qEMACS Version:\[1
FTEMACS/Datamedia Editor, version 1 - type ^_ (the "hold" key) for help.
]1
!''!''
FQ0-1"LQ1"NM1'
]1]0]J:M..9'
QInhibit Write,M(M.MVisit File)0
FSLISPT"NF~JSNDMSG"N
QBuffer FilenamesF[DFILE
0FSDVERS
FSDFILEUBuffer Filenames
M(M.M& Set Mode Line)
F]DFILE''
Q1"NM1'
]1]0]J:M..9^R Define Kbd Macro*qDefining Kbd Macro"E
0fsbconsm.vKbd Macro Defining Body
0m.vKbd Macro Defining Index
m.m& Define Kbd Macrofstyisink
1uDefining Kbd Macro
:M(M.M& Set Mode Line)'
"#
qKbd Macro Defining Body[..o
qKbd Macro Defining Indexj.,zk
j<:s;ric>
ji!temp!m(m.m& immediate Kbd Macro)
zj27i
hx*m.vLast Kbd Macro
Q..o(]..o
)fsbkill
0fstyisink
0uDefining Kbd Macro
:M(M.M& Set Mode Line)'DM Save File3"E:M(m.m^R Save File)'
1:M(m.m^R Save File)^R Save Filey0FO..QDebug Save File"NSFORCE ERROR'
Q..F-Q.F"N0'
QAuto Save Mode[1
FSMODIFIED"E
FF&1"N
QAuto Save Count"N
Q1-2"E
-1FSMODIFIED''''
FSMODIFIED"E
@FT
(No changes need to be written)
0FSECHOACT'
QBuffer Filenames[0
1[2
Q1-2"EFF&1"E
QAuto Save FilenamesU0-1U2''
Q0"E"N'
:I*No filenames to save underFSERR'
"N3*FSZ-(2*QAuto Save Size)"L
-2"E@FT
(File has shrunk -- not auto-saving)0FSECHOACT'
0F[TYISOURCE
@FT
File has shrunk a lot.  Save anyway
@FG1M(M.M& Yes or No)"E0FSERR'''
Q0F[DFILE
Q2"G
FSDDEVICE-(F6DSK)"E
1:<ERFSIFCDATE[4EC
Q:.B(QBuffer Index+8)[3
Q4"NQ3"NQ4-Q3"N
FTThis file has been written on disk since you last read or wrote it.
Should I write it anyway
M(M.M& Yes or No)(FSwindow+b,zf0u..h)"E0''''>''
Q2,M(M.MWrite File)0
Q1"N
%Auto Save Count
FSDVERSIO"E
Q1-2"EFF&1"E1:<ED <!>!>
''
"#QAuto Save Count-QAuto Save Max"G
%Auto Save DeleteF"GFSDVERSIO
1:<ED>'''''
FF&1"N0UAuto Save Count'
0DM Toplevel ^R7F~Editor Name..J*+fqEditor Name+1"N
f=..j(-1"g0'
[..J:I..J[..J ^R] 0:'
M.M& Recursive ^R Set ModeF[^RENTER
F<!TOPLEVEL ^R!

-1FO..Q^R Exit Flag@;
1:<
FQMM Quit"GMMM Quit'
"#
QBuffer Filenames"N
1M(M.M^R Save File)'
QAuto Save Mode"N
QAuto Save Filename[1
:<ED1>
]1'
FSXJNAME:F6[J
F~JSNDMSG"N
@FTGood-bye.'
]J
100000.FSEXITW'
>F"NFG'
>
@V
FS^RMODE"NFS^REXIT'
fsbackdepth"n'DM Secretary MacroFSMODIFIED"E0'
QAuto Save Mode"E0'
FSZ"E0'
FS^RMODE"E0'
@FT (Auto Save)
1:<2,M(M.M^R Save File)>
FSRGETTY"EF+'
0^R Forward TECO Iterationu0[1.[3
.(:S
:FSZ-.F[VZ)J
<:S<>!*;
0A-<"E%1'!>!
!<!0A->"EQ1-1U1Q1-1"L0''
0A-*"ES!'>
Q3JFG0^R Backward TECO Iteration0[1[2.[3
.(-:S
:.F[VB)J
<-:S<>!
;
1A-<"EQ1-1U1Q1-1"L0''!>!
!<!1A->"E%1'
1A-!"E.U2-S!
2A-*"NQ2J''
>
Q3JFG& Setup KBDMAC Librarym.m^R Start Kbd Macrou:.x(()
m.m^R End Kbd Macrou:.x())
m.m^R Call Lastu:.x(E)
:i*m.vLast Kbd Macro
20.*5fsqvectoru..m
q..m[..ohk& Run Kbd Macroq:..m(fq..m/5-1)[0
q:..m(fq..m/5-2)[1
q1:g0*200.+(%1:g0)fsreread
%1u:..m(fq..m/5-2)
q1-fq0"l0'
q..m[..ozj-10d
z"e0fstyisource'
0& Call Kbd Macrotq..m[..o
fstyisource"ehk'
f"e1'<
zj10,0i
0,.-10fsword
,.-5fsword>
m.m& Run Kbd Macrofstyisource
0& Immediate Kbd Macro$,:i*:m(m.m& Call Kbd Macro)^R Call Last Kbd MacromLast Kbd Macro^R Start Kbd Macrom0fsbconsm.vKbd Macro Defining Body
0m.vKbd Macro Defining Index
m.m& Define Kbd Macrofstyisink
0& Define Kbd MacrorqKbd Macro Defining Body[..ozj
fstyibeg-(fstyicount-1)"e
zuKbd Macro Defining Index'
/200.i&177.i0^R End Kbd MacroFqKbd Macro Defining Body[..o
qKbd Macro Defining Indexj.,zk
j<:s;ric>
ji!temp!m(m.m& immediate Kbd Macro)
zj27i
hx*m.vLast Kbd Macro
Q..o(]..o
)fsbkill
0fstyisink
0Name Kbd MacroC1,fCommand Name[1
fq1"gqLast Kbd Macrom.vMM 1'
:i..0^R Command to define: 
m(m.m& Read Q-reg)[2
f=2
"e0'
f=2"e0'
q2m(m.m& Check Redefinition)
qLast Kbd Macrou2
0View Kbd Macro:i*[0
:i..0Kbd Macro Command: 
fq0"em(m.m& Read Q-reg)u0'
q0[1
m.m^R Call Last Kbd-q1"e
qLast Kbd Macrou1
:i0Last Kbd Macro'
f[bbindg1
js)0,.k
zj-d
ft
Definition of keyboard macro 0:


m.m& Charprint[2
jz/2<1a*200.+(2c0a)m2ft >
ft

0& Check Redefinition'[1
q1[0
fq0+1"g
f~(0,6:g0)!Temp!"n
!lose!!"!:I*Can't clobber specified character 1fserr''
"#Afs^rinit-q0"n
200.@fs^rinit-q0"n
q0"n
olose''''
~FILENAME~
DATAMEDIA~DOC~ ~FILENAME~Library to rearrange the command set for easy use from
SRI-style Datamedia keyboards.  Commands are summarized in the file
<EMACS>DATAMEDIA.CHART .
#~DOC~ & Setup DATAMEDIA Library& Setup macro
~DOC~ Datamedia<C Set up the EMACS/Datamedia environment.
Rearranges the command set for easy use from SRI-style
Datamedia keyboards.  Commands are summarized in the file
<EMACS>DATAMEDIA.CHART .
&~DOC~ ^R Complement Overwrite Mode|
^R If Overwrite Mode is on, turn it off.  If it is off,
turn it on.  When Overwrite Mode is on, typed non-meta characters
will delete and overwrite characters in the buffer instead
of being inserted.  Meta characters still function normally.
~DOC~ Goto PagekC Move forward or back by pages, or to specific page.
If no arg, go to top of next page.
If arg is zero, go to top of present page.
If arg is negative, go to top of present page, unless already at top,
	in which case go to top of preceding page.
If arg is positive (+n), go to top of page n of buffer.
If two args (m,n), go to line m of page whatever.
~DOC~ ^R Copy LinesU^R Like killing lines and getting them back,
but doesn't mark buffer modified.
~DOC~ ^R Set Fixed Mark_^R Set either THE mark, or special fixed mark.
If no arg, set "ring-of-point" mark.
If arg is zero or positive, set corresponding fixed mark.
There are 10 fixed marks, numbered 0 to 9.  They contain character
counts relative to the beginning of the buffer.  Fixed marks may
be changed only by this macro, and are unaffected by killing, etc.
~DOC~ ^R Goto Fixed Mark4^R If no arg, exchange point and "ring-of-point" mark.
If negative arg, pop the "ring-of-point" mark.
If zero or positive arg, set "ring-of-point" mark and goto fixed mark.
~DOC~ ^R Zap to Character[^R Kills text up to but not including a
target character.  Uses the macro ^R Character Search to obtain
the target character from the keyboard and search for it.  The search
skips over the character pointed to.

~DOC~ ^R Zap thru Character%^R Kills text up to and including a
target character.  Uses the macro ^R Character Search to obtain
the target character from the keyboard and search for it.
~DOC~ ^R Forward Word$^R Move forward over one word.
 ~DOC~ ^R Forward End-of-Word+^R Move forward to the next word end.
!~DOC~ ^R Backward End-of-Word@^R Like Backward Word, but moves to end of
previous word.
~DOC~ ^R Kill Word0^R Kill next word and trailing delimiters.
 ~DOC~ ^R Kill to End-of-Word
^R Kill to next word end.
)~DOC~ ^R Backward Kill to End-of-WordE^R Like Backward Kill Word,
but kills to end of previous word.
~DOC~ ^R Kill into Q-reg ^R Put Q-reg and Kill text
~DOC~ ^R No-op^R Does nothing.
~DOC~ DM Where Am I^R Print various things about the cursor position.
Print the page and line,
the X position, the Y position,
the octal code for the following character,
cursor position in characters and as a percentage of the total file,
and the virtual boundaries, if any.
~DOC~ ^R TECO Search/^R Search, using the basic TECO string search facility.
Special characters:
^B matches any delimiter char.
^N matches any char other than the char following it in the search
	string (i.e., "not").  ^N^B matches non-delimiters, and
	^N^X matches nothing.  ^N^Q^B matches all but ^B, etc.
^O divides the string into substrings searched for simultaneously.
	Any one of these strings, if found, satisfies the search.
^Q quotes the following char, i.e., deprives it of special significance.
	Escape and rubout cannot be quoted.
^X matches any char.
~DOC~ DM Query ReplaceC
^R Replace string, asking about each occurrence.
Query Replace:FOOBAR displays the next FOO;  you say what to do.
Space => replace it with BAR and show next FOO.
Rubout => don't replace, but show next FOO.
Comma => replace this FOO and show result, waiting for next command.
Period => replace this FOO and exit.  Altmode => just exit.
^ => return to site of previous FOO (actually, jump to mark).
^W => kill this FOO and enter recursive ^R.
^R => enter ^R mode recursively.  ^L => redisplay screen.
Exclamation mark => replace all remaining FOOs without asking.
Any other character exits and is read again.
If QCase Replace is nonzero, BAR will be capitalized or all caps 
if FOO was.
1 MM Query ReplaceFOO... will replace only FOOs that are
bounded on both sides by delimiter characters (according to ..D).
~DOC~ Grind SexpZC Grind the sexp after the pointer.
A modification of the MIT Grind Sexp that recognizes that
in Interlisp, % quotes a character, " starts a long
string, and ; has no significance.
Uses QMiser Column to decide where to start using "Miser" format,
and QFill Column as the page width to aim for.
Saves the old sexp on the kill ring.

~DOC~ DM Incremental Search5^R Search for character string.
As characters are typed in, the accumulated string is
searched for.  Characters may be rubbed out.
^Q quotes special characters.
^S or M-S repeats the search forward; ^R or M-R repeats it backward.
If the accumulated string is empty, ^R, ^S, M-R or M-S either
reverses the direction of search or gobbles the previous
search string and searches for it again.
Altmode or any random control character exits
(anything but altmode is then executed).
If the accumulated string fails to be found,
you will be notified with one bell.  You can then exit,
rub the bad characters out (or ^G them all away),
or try searching in the opposite direction.
Quitting a successful search goes back to the starting
point of the search;  quitting a failing search rubs out
enough characters to make it successful again.
Altmode when the string is empty makes the search
non-incremental by calling ^R String Search.
'~DOC~ DM Reverse Incremental SearchZ^R Incremental Search Backwards.
Calls Incremental Search with a negative argument.
~DOC~ DM Character Search{^R Search backward for a single character.
Special Characters:
   ^A	Call ^R String Search; use MM Describe to see what that does.
   ^F	Position window so search object is near top
   ^Q	Quote following character
   ^R	Reverse search direction and read another char
   ^S	Search for default
        Also done if character macro is called by is typed again,
	overides any other function of that character shown here.
   ^T	Search for Teco default
If ^S is not used, the character typed becomes the default
for future searches.  Defaults are kept separate
from the regular TECO "S" command and from Incremental Search.
%~DOC~ DM Reverse Character Search{^R Search backward for a single character.
Special Characters:
   ^A	Call ^R String Search; use MM Describe to see what that does.
   ^F	Position window so search object is near top
   ^Q	Quote following character
   ^R	Reverse search direction and read another char
   ^S	Search for default
        Also done if character macro is called by is typed again,
	overides any other function of that character shown here.
   ^T	Search for Teco default
If ^S is not used, the character typed becomes the default
for future searches.  Defaults are kept separate
from the regular TECO "S" command and from Incremental Search.
~DOC~ LISP ModeOC Sets things up for editing LISP code
within the Datamedia environment.
~DOC~ SAIL Mode0C Sets things up for editing SAIL programs
~DOC~ MIDAS ModeDC Set things up for editing MIDAS code.
M-F and M-B go to address and AC fields, respectively.
C-M-F and C-M-B go to next and previous label.
Paragraphs are delimited only by blank lines.
~DOC~ MACRO ModeDC Set things up for editing MACRO code.
M-F and M-B go to address and AC fields, respectively.
C-M-F and C-M-B go to next and previous label.
Paragraphs are delimited only by blank lines.
~DOC~ TECO ModeRC Set things up for editing TECO code.
Makes Rubout the Tab-hacking Rubout.
Loads the PURIFY library.  Makes comments be bounded by "!* " and "!".
M-F moves forward over a TECO conditional;  M-B, back.
~DOC~ Text ModesC Set things up for editing English text.
Makes Auto Fill not indent new lines;  says there are no comments.
~DOC~ & SAI ModeS Setup for SAIL.
~DOC~ & LSP Mode~DOC~ & LISP ModeS Setup for LISP.
~DOC~ & PUB ModeS Setup for Text mode.
~DOC~ Auto Fill ModehC Turn Auto Fill mode on or off.
No arg or argument of 1 turns the mode on;
any other arg turns it off.
When it is on, lines are broken at the right margin
(position controlled by QFill Column) at spaces,
by doing a LF.
~DOC~ DM Indent New Line^R Inserts CRLF, then indents the second line.
Any spaces before the inserted CRLF are deleted.
Uses the definitions of CR and Meta-Tab to do the work,
except that if there is a Fill Prefix it is used to indent.
An argument is passed on to the definition of Meta-Tab.
~DOC~ DM Indent Nested^R Indent line for specified nesting level.
With no argument (or argument 1) indents the line at the same nesting
level as the last nonblank line (ie, directly under it).
A larger argument means that this line is that many levels
closer to the surface, and should indent under the last line
above it whose level is the same.  The previous lines are scanned
under the assumption that any line less indented than its successors
is one level higher than they.
A negative arg N indents to the right of the previous nonblank line;
the amount of additional indentation is N times Q$Indentation Increment.
Unindented lines and comment lines are ignored.
If the cursor is not at the beginning of a line, the whole line
is indented, but the cursor stays fixed with respect to the text.
~DOC~ Startup DatamediaC Initialize for editing, process JCL and edit.
Intended to be called from the user init file, instead of reading
<EMACS>EMACS.INIT.
~DOC~ ^R Define Kbd Macro=C Begin defining keyboad macro.
After you type this command, until you type it again,
everything you type becomes
part of the accumulating keyboard macro as well as being executed.
~DOC~ DM Save Filel^R Save Buffer on Disk if Modified.
With zero arg, use Auto Save Filename,
else use Buffer Filename.
~DOC~ ^R Save Filee^R Save buffer on disk if modified.
Auto Save mode uses this macro.
If auto-saving is enabled, then we write to filenames read
or to a separate auto-save filename.  If auto-saving is off,
or if given an argument, we always write to the filenames read.
"1," as argument indicates that this call was not explicitly
requested, and the user should be asked to confirm if
the file has become a lot smaller.  "2," means an auto save,
which should abort if the file is shrunken.
~DOC~ DM Toplevel ^R"S Enter a loop entering ^R mode within a catch.
Useful as a toplevel macro to be assigned initially to FS ^R ENTER.
The macro MM Top Level will then pop up and into the outermost ^R.
If Q^R Exit Flag is zero, then ^Z will revert to the TECO command loop.
Otherwise if QMM Quit is a string, then it will be macroed.
Otherwise, the file will saved and EMACS will halt.  A continue will
re-enter ^R mode.
~DOC~ DM Secretary Macro.S Standard ..F:  Auto-save for use in ^R mode editing.
If QAuto Save Mode is  non-zero, the buffer is saved
(as by ^R Save File) after every FS ^R MDLY characters.
#~DOC~ ^R Forward TECO Iteration2^R Move past the > matching the following <.
$~DOC~ ^R Backward TECO Iteration7^R Move back past the < matching the preceding >.
 ~DOC~ & Setup KBDMAC Library6S Put commands on keys.  Create execution stack.
~DOC~ & Run Kbd Macro?S This is the FS TYI SOURCE for running keyboard macros.
~DOC~ & Call Kbd MacroS Push a kbd macro onto the execution stack of such.
The macro to be called is supplied as a string pointer.
A pre-comma argument is a repeat count.

~DOC~ & Immediate Kbd MacroS Push a kbd macro supplied as a suffix string arg.
This subroutine is for use in definitions of ^R commands
which directly run keyboard macros.
 ~DOC~ ^R Call Last Kbd Macro^^R Run the last defined temporary keyboard macro.
A numeric argument is a repeat count.
~DOC~ ^R Start Kbd Macro#C Begin defining keyboad macro.
After you type this command, everything you type becomes
part of the accumulating keyboard macro as well as being executed.
~DOC~ & Define Kbd Macro3S FS TYI SINK for defining kbd macros.
Takes characters typed and accumulates them in a buffer
which will be formed into a keyboard macro when the definition is finished.
~DOC~ ^R End Kbd MacroZC Terminate definition of a keyboard macro.
All that you have typed since starting the definition,
except this command itself, becomes the definition.
^R Call Last Kbd Macro re-executes the last macro defined.
~DOC~ Name Kbd Macro,C Give a name to the last kbd macro defined.
An MM command is created with the name you specify,
which when invoked runs that keyboard macro.
Then, you are asked to give the command character to
put the macro on.  Type Return or Rubout if you don't want
to put it on any character.  Otherwise, type a character
which is undefined or is already a keyboard macro.
Prefix characters such as Altmode and ^X may be used.
~DOC~ View Kbd MacroKC Print definition of a keyboard macro.
Supply a suffix string argument containing the command name.
If the string argument is null, you will be asked to type
the character which runs the macro.
~DOC~ & Check RedefinitionS Verify that a certain command can be redefined.
Do not allow a command to be redefined unless it is undefined,
self-inserting, or a string starting with !Temp!.
The command is specified with a q-register name in a string
passed as a string pointer.
~DIRECTORY~%& Setup DATAMEDIA Library
Datamedia
^R Complement Overwrite Mode
Goto Page
^R Copy Lines
^R Set Fixed Mark
^R Goto Fixed Mark
^R Zap to Character
^R Zap thru Character
^R Forward Word
^R Forward End-of-Word
^R Backward End-of-Word
^R Kill Word
^R Kill to End-of-Word
^R Backward Kill to End-of-Word
^R Kill into Q-reg
^R No-op
DM Where Am I
^R TECO Search
DM Query Replace
Grind Sexp
DM Incremental Search
DM Reverse Incremental Search
DM Character Search
DM Reverse Character Search
LISP Mode
SAIL Mode
MIDAS Mode
MACRO Mode
TECO Mode
Text Mode
& SAI Mode
& LSP Mode
& LISP Mode
& PUB Mode
Auto Fill Mode
DM Indent New Line
DM Indent Nested
Startup Datamedia
^R Define Kbd Macro
DM Save File
^R Save File
DM Toplevel ^R
DM Secretary Macro
^R Forward TECO Iteration
^R Backward TECO Iteration
& Setup KBDMAC Library
& Run Kbd Macro
& Call Kbd Macro
& Immediate Kbd Macro
^R Call Last Kbd Macro
^R Start Kbd Macro
& Define Kbd Macro
^R End Kbd Macro
Name Kbd Macro
View Kbd Macro
& Check Redefinition
~INVERT~[1<Q1-1U1Q1FP;>Q1
