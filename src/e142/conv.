-*-Text-*-

File: CONV	Node: Top	Up: (DIR)	Next: Init

Programming in TECO for EMACS

* Menu:

* Init Files: Init	INIT files and what they can do.
* Syntax: Syntax	Syntax library source files to be compiled by
			the EMACS library compiler.
* Libraries: Lib	Other conventions for Libraries and sources.
* Programming: Prog	Conventions for TECO programs to be operated
			in the EMACS enviromnment.
* Variables: Vars	Named variable (QFoo, etc) conventions.
* Major Modes: Major	How to define new major modes.
* Submodes::		How to define submodes.
* Prefix::		Prefix characters, such as C-X.
* Hooks::		Variables which EMACS will call at specific times.
* Dump::		Dumping EMACS environments.
* Build::		Building and dumping a new EMACS.
* Wall Charts::		Making wall charts.
* Q-registers: Qregs	Conventions for use of Q-registers.
* FS ^R PREV$: FS^RPREV	Conventions for setting/examining FS ^R PREV.
* Debugging: Debug	Debugging aids in EMACS.

File: CONV	Node: Init, Up: Top, Previous: Top, Next: Syntax

INIT Files.

  Each user can have his own file of TECO commands for EMACS to
execute each time he starts it up.  EMACS looks for the file
<hsname>;<user> EMACS and then for <hsname>;* EMACS, where <hsname>
stands for the user's home directory.  If neither file exists, the
file EMACS;* EMACS (the default init file) is used instead.
On Twenex, the init file is called EMACS.INIT in your login directory,
and the default init file is <EMACS>EMACS.INIT.

  You can cause an EMACS to read another user's init file by giving it
that user's name as its XUNAME;  just do <user>^S in DDT immediately
before starting the EMACS.

  Setting up the default ^R command definitions and named variables
need not be done in an init file, since that is done before the EMACS
environment is dumped out.  As a result, your init file need only
define those commands which you wish to change.  Use MM Load Lib to
load any additional libraries (or the :EJ command, for libraries which
have no & Setup <library> Library macro).  To obtain a function as a
value so you can put it on a character, simply use M.M <name> .  The
U command can define a character, as in for example U..^RX which puts
its argument on Meta-X.  Use M.V to create and assign a variable, or
better yet M.C to give it some documentation as well.

  When the init file is started, all q-registers not used by EMACS
(and described herein) will probably be zero.  One exception is Q1,
which contains the version number of [PURE], as a string.  The default
init file types this out as the "EMACS version number".

  If you have no init file, EMACS runs the default init file, which is
the init file on the EMACS directory.  This does various things such
as processing a command line from the superior, loading LISPT if
necessary, printing the EMACS version number and offering help,
checking for lower case characters on an upper-case only terminal, ...

  Most people will find that they wish to perform the actions of the
default init file after their own peculiar initializations.
To do this, just end your own init file with

      ER EMACS;* EMACS @Y ET@ > :M(HFX*)

(On Twenex, do EREMACS;EMACS INIT or ER<EMACS>EMACS.INIT instead)
This practice is recommended because some of the things in the default
init file are important for the proper functioning of EMACS.
If you wish to override the default init file's offer of help, or the
JCL processing, then instead of doing the :M with an empty buffer you
should put in the buffer a string to be treated as if it were the JCL.

      FJ
      Z"E I<what to use for JCL when there is none>'
      ZJ .F[VB
      ER EMACS;* EMACS ^Y ET@ >
      :M( HFX*( F]VB))

Putting just Altmode Space in the buffer when there is no JCL will
prevent the default init file from offering help.  For this, use
Z"E I ' in the above example.

  If you have enough of your own macros to have a private library of
them, you need not have both the library and an init file to load the
library.  You can just call your library <user> EMACS and give it a
~Filename~ of INIT and a & Setup INIT Library macro to perform the
other initialization.  The & Setup INIT Library macro should end by
reading in the default init file, just as an ordinary init file
should, but the calling convention is slightly different:

      :I..9 ER EMACS;* EMACS @Y ET@ > :M(HFX*)

  This section does not intend to be intelligible without reference to
TECO ORDER and to the rest of this file.

File: CONV	Node: Syntax, Up: Top, Previous: Init, Next: Lib

Syntactic Conventions for TECO Macro Files:

  A source file of EMACS macros contains one macro on each page.  Each
macro has a name and documentation as well as its definition.  These
source files are processed by a compressor which deletes spaces and
comments and performs other syntactic transformations before they are
run.  You can also ask to compress and install a single macro, for
testing, by pointing at it and using MM Compile.

  Every macro's definition begins with the macro name, which is
preceded by a ! and followed by :!.  You must not ever put a :!, even
with spaces in between, in a macro source file except to end a macro
name.  The macro name must be the first thing on a page except for a
CRLF which must follow the previous formfeed on pages after the first.
The name conventions are that subroutine names start with "& " and
names of commands intended to be put on characters start with "^R ".
This is to keep them from limiting the user's ability to abbreviate
the names of commands he wishes to type.  Another convention is that
"#" begins the names of commands which form a dispatch table.  For
example, in INFO, the command M causes # INFO M to be run.  If you
define a command named # INFO +, that will automatically give you an
INFO command called +.

  After the macro name comes a space, an !, and then the macro class.
Then, after another space, the rest of the line is the "brief"
documentation which is used when only a single line is wanted.  It
should be a complete sentence.  The macro class should be the
character C for a command which users should call by name, S for a
command intended to be used as a subroutine, and ^R for a command
intended to be placed on a character.  The macro class does not
restrict how the macro can actually be used;  some of the
documentation commands filter commands to be described by class.

  The macro may have only the brief documentation.  In this case, the
brief documentation should be followed by an !.  Otherwise, the lines
following the brief documentation are the full documentation, which
ends with the first !.  The ! must be at the end of its line, and
should not be an excuse to omit punctuation for the last sentence,
since it will not be seen by the user.  To put an ! in the text of the
documentation, use control-^.

  After the line ending with !, the next line contains the beginning
of the macro definition proper.  Usually, a blank line is put there to
improve readability.  You must remember that the definition will not
be used as written, but will be processed syntactically first:  all
spaces and tabs, except those following a ^Q, will be deleted.  all
_'s not following a ^Q will be turned into spaces.  !* is taken to
start a comment and everything from there up to and including the
following ! is deleted (again, a ^Q will prevent this).  Double CRLFs
are converted to single ones.  Normally, you should use ^]^Q to do
such quoting, since that is safe in all contexts.  Inside search
commands and file commands a ^Q by itself is enough.

  Every macro definition should end with a CRLF, after which may come
a ^L and the next macro definition.  Macro definitions are separated
only by CRLF ^L CRLF.  A ^L in the middle of the line is just part of
a macro.  If you want to put CRLF ^L CRLF inside a macro, use CRLF
^]^Q^L CRLF.

  The major mode TECO Mode is useful for editing EMACS source files.
Comments are defined to start with !* and end with !.
Tab is set to the command ^R Indent Nested, which normally moves the
current line to be under the previous line.  With an argument, it
takes the argument to be the number of levels "up" to go, where up
means a lesser amount of indentation.  Thus, Tab with an argument of 2
or more is good for the first line after the end of a conditional or
iteration.  In addition, unindented lines and lines containing only
comments are ignored.  In addition, Meta-' is defined to move forward
over a TECO conditional, and Meta-" to move back.  You might wish to
set the variable QFS CTLMTA to -1 in your TECO Mode Hook variable,
thus making control-meta characters insert control characters.  If you
do this, you must also make QSwitch Modes Process Options locally
nonzero.

File: CONV	Node: Lib, Up: Top, Previous: Syntax, Next: Prog

Library File Conventions

  The command Generate Library, in the library EMACS;PURIFY :EJ, is
used to generate :EJ'able libraries from source files following the
syntactic conventions.  The operation has two logical subparts:
compression, which removes spaces and comments, and extracts the
documentation into separately named macros;  and purification, which
converts the intermediate form into a :EJ'able library.  It is
possible to divide the source for a large library into several
subfiles, which will be compressed separately but purified together.
This saves time if only some of the subfiles are modified, since the
compressed versions are saved in separate files and reused if more
recent than the sources.  Generate Library handles such multi-file
sources automatically if all the source files' names are given to it.

  One of the source files going into a library should define a
"command" named ~Filename~.  The "definition" of this command should
be some kind of identification for the file.  It should usually be the
same as the first filename of the library.  The documentation for
~Filename~ should describe the purpose of the library as a whole.

  Generate Library automatically creates a ~Directory~ object which
contains a list of all the macros in the file.  A library should never
contain two macros with the same name (~Filename~ is an exception:
see below).

  Sometimes it is desirable to merge several library sources into one
:EJ file.  If you always like to use, say, TAGS :EJ, and have a
private library, you may save space and increase speed by including
the source of TAGS when generating your private library.  This,
however, means that you need to be able to override the ~Filename~
macro which comes from the source of TAGS.  Generate Library solves
this problem by deleting all but the first ~Filename~.  Your private
source file must come first, and contain a ~Filename~, to override the
one in the TAGS source.

  Libraries intended to be accessed via the Run Library command should
contain a macro named <ENTRY>, which will be the default entry point,
so that the user need not specify the entry point name.  In addition,
they MUST have a ~FILENAME~ which is identical to the actual first
name of the file, so that Run Library can tell whether the library is
already loaded.

  If a library contains a macro named & Setup <libname> Library, where
<libname> is the library's ~Filename~ name, then whenever the library
is loaded with MM Load Library that macro will be called.  It can be
used to put some of the library's macros on ^R characters, for
example.  If it is used for that purpose, then it should allow the
user to override it by setting up a named variable.  For example, the
TAGS library has an & Setup TAGS Library macro, which defines Meta-..
However, if the variable TAGS Setup Hook is nonzero, & Setup TAGS
Library executes that variable instead of its default actions.  Thus,
a user's init file can specify where the TAGS commands should go if
TAGS is ever loaded, by defining TAGS Setup Hook.

  In addition to the names of macros, there are several names that
(usually or always) be found in purified files of EMACS macros.  For
every macro FOO, an object named ~DOC~ FOO is available, that contains
FOO's documentation.  In addition, ~DIRECTORY~ contains a list (one
per line) of all the macros that the file wishes to advertise that it
contains.  Special things such as described in this section, and all
commands with ~ in their names, are not included.

  ~INVERT~ is supposed to be a macro that is the inverse of the loader
macro.  That is, <object in file>,<pointer to file> fed to the
~INVERT~ macro should return a string containing the name of the
object.  You should not have to be aware of ~INVERT~, because it will
be provided automatically, and called by & Macro Get Full Name when
necessary.

  The BARE library, which contains definitions of the raw TECO ^R-mode
commands, has a different loader macro and so must be generated in a
special way.  The command MM BARE Library Generatesource-file-name
will generate and write out the BARE library.  The difference in the
loader macro is simply that if a macro's definition is three
characters long or fewer then it is treated as the name of a ^R
command character (as in .^RA for C-A) and that character's initial
raw-TECO definition is returned instead.  If the macro's definition as
found in the ordinary way is longer than three characters, it really
is the definition.  This way, documentation strings act normally but
the command names themselves can return the raw TECO commands as their
definitions.  BARE has a ~INVERT~ macro which knows how to find the
names of raw TECO commands as well as strings in the library.
However, & Macro Get Full Name has to know specially that such
commands, which are positive numbers rather than strings, should be
passed to the BARE library to invert.

File: CONV	Node: Prog, Up: Top, Previous: Lib, Next: Vars

Programming Conventions

  For good programming practise, every CRLF that is not
part of a string argument should be followed by an indentation
to a position that indicates the current depth in iterations
and conditionals.  Use of the Tab command will make this easy.

  Since the FS S ERROR$ flag is normally set in EMACS, searches that
are followed by ";" must always be given the ":" modifier; otherwise,
they will cause errors when they fail, before noticing the ";".  This
is because, if FS S ERROR$ is not set, a user who types an iteration
in the minibuffer and omits the ";" is likely to cause himself extreme
lossage.  The Tab TECO command is disabled in the EMACS environment,
and is a no-op.  Use 9I or I^]^Q<tab> to insert a tab.

  Use named subroutines whenever convenient.  The subroutine
should usually have documentation beginning with "S "
so that users doing a "List Commands" will not see it, and
a name beginning with "& " so that it will not interfere with the
user's attempt to abbreviate command names.
Call the subroutine with M( M.M&_Subroutine$)  (note the
_ is used to get a space).  MM&_Subroutine$ would work, but
macros are not supposed to depend on having no-dot q-regs
set up.

  The normal EMACS command level is precisely the TECO ^R command,
with characters redefined to run EMACS macros or user-supplied macros.
All of the information in TECO ORDER on the ^R command, facilities
available for macros which are definitions of ^R characters, and what
values should be returned by such macros, are very important for
anyone who writes macros which are to be placed on characters.

  The mark is kept in TECO's "Ring buffer of point".  It's value can
be obtained with :^V with no argument;  <arg>:^V will push a new value
of the mark.  ^V with no colon can be used to pop the mark (read TECO
ORDER for details).  One consequence of this scheme is that there is
always a mark somewhere.  Note that the ^W EMACS command POPS the
mark, rather than leaving a useless mark at point.

  Commands that take input should do M.I before actually reading it.
That will prompt for the input.  The user may redefine .I if he wishes
to eliminate prompting, but even so he should still define all his
macros to use M.I so that other users will receive the behavior they
want.

  Commands that call ^R on data that the user is likely not to regard
as "the thing he is editing" should do 0[..F before the ^R, to turn
off auto-saving, and inhibit window, buffer or file switching (either
of which would cause garbage results if allowed to proceed).  See the
& Check Top Level subroutine.  They should also bind the default
filenames to GAZONK .DEL, which will prevent the user from screwing
himself with a ^X^W.

  No non-dotted Q-regs should be reserved by the macros, except for
user interfaces like MM.  Also, avoid using double-dot Q-regs except
as defined in TECO ORDER.  All temporary Q-regs should be pushed and
popped.  All macros should return with ^\ if possible.

  When you wish to make a ^R command that checks for the
presence of a ^U as an argument, the conditional to use is
F^XF^Y"N, which succeeds if there was an explicit argument (^U or
otherwise).  This makes it convenient to use the macro as a
subroutine, since then one can give it an argument of 1 to mean
"^U", and no argument to mean "no ^U".

  Anything that changes information which is displayed in the mode
line should do 1FS MODE CHANGE so that FS MODE MACRO will eventually
be run to update q-register ..J and thus the mode line.

  If you wish to read input from the user, if it is only a few
characters you can use M.I.  But if it can be long or complicated
then rather than writing your own editing facilities for the input
you should use the minibuffer to read it.  Simply call & Minibuffer
with the buffer containing any initialization for the input, and on
return take the contents of the buffer as the user's string.  See
the documentation of & Minibuffer for more details.  Alternatively,
you can read the input with & Read Line, but then the only editing
available will be Rubout.

  I suggest that, if you intend to do any significant programming, you
do MM List Subroutines to find out what is available to you, and read
some of the EMACS source code.

File: CONV	Node: Vars, Up: Top, Previous: Prog, Next: Major

Named Variable Conventions

  EMACS makes extensive use of named variables, and provides features
for creating, destroying, editing, and listing them.

  The basic way of getting the value of a named variable that already
exists is to do Q<name>.  See TECO ORDER for details.  If you are
not sure whether a variable exists, you can do <default> FO..Q <name>
which will return the value if the variable exists, or <default> if
the variable does not exist.  :FO can be used to tell whether a
variable exists.  Any TECO command that can use a q-register, except
for ^], can also use an existing named variable if it is given the
name of the variable, surrounded by Altmodes, as the q-reg name. 
Although TECO allows unambiguous abbreviations of the name to be used,
it is unwise to use abbreviations in a program.

  To create a variable, do <value>M.V<name>.  Unlike Q and FO, M.V
does not manage to handle leading, trailing, or multiple spaces;  any
variable created with them in its name will be inaccessible (of
course, in a library source file, spaces and tabs are deleted anyway,
and to get a real space you must use "_").  If the variable already
exists, its value will be set, and the old value will be returned. 
For a new variable, 0 is returned.  A variable can have a comment as
well as a name and a value.  To create a variable and give it a
comment, do <value>M.C<name><comment>.  Aside from setting the
comment, M.C is just like M.V.

  Sometimes it is more efficient for changing a variable's value to
redefine some command characters, instead of having one definition
which always checks the value of the variable.  Do this by providing a
macro to be run whenever the variable's value is changed.  This macro
is supplied by making it the variable's comment.  Whenever the comment
begins with a "!" it is taken to be a macro to be run in this manner.

  If you want a variable to be presented for editing by MM Alter
Options, you should give the variable a comment which starts with a
"*".  If the variable is to have a macro to run when it changes, and
so the comment must start with a "!", then the variable is an option
if the comment starts with "!".  NOTE: if you are not careful, the
TECO code to set up such a variable will contain "!*" which will be
taken as the beginning of a comment.  Leaving a space (which will be
removed by compression) between the "!" and the "*" will prevent such
lossage.  See where the file EINIT sets up such variables if this
isn't clear.

  You can examine the value, and comment if any, of a variable by
doing MM Describe<name>, just as you would ask for the documentation
of a macro.

  Variables can be local to an individual buffer.  To make a variable
local to the current buffer, do <value>M.L<name>.  From then on,
setting the variable when the current buffer is selected will not
affect its global value, which other buffers will continue to see,
nor will changing that global value affect the local value.  Each
buffer in which the variable is made local has its own value for the
variable, while all other buffers share one global value.
Doing M.L has the side-effect of creating the variable globally
with the value of 0 if it did not already exist globally.  Local
variables will be created automatically when a file is visited which
contains a local modes specification at the end.  They are also the
way in which major modes perform their redefinitions.

  There are two times when local variables are usually created:  when
a buffer is created, and when a major mode is specified.  EMACS
automatically creates several local variables for each new buffer;
the Buffer Creation Hook variable will be executed and can create some
more.  These locals will remain permanently in existence.  All local
variables created after that time will be killed whenever the major
mode is changed.  This is how one major mode undoes the redefinitions
performed by the previous major mode.  A consequence is that any
explicitly created local variables will also be lost when the major
mode is specified (and, therefore, whenever a file is visited which
specifies its mode).

  Not only variables, but q-registers as well (including ^R command
character definitions), can be made local.  To make a q-register
local, use the Make Local Q-register command, with the q-register name
as a string argument:  M.QA makes QA local, and M.Q.^RF makes the
definition of Control-F local.

  You can override the library definition of an M.M macro by defining
a variable named "MM " followed by the macro name.  M.M checks for
such a variable before looking the name up in the loaded libraries.
MM Compile installs the compiled macro in just this way.  A few such
MM variables are present in the default environment.  This is to make
calling certain key subroutines more efficient;  M.M takes less time
finding the variable than searching the libraries.

  To see a list of all existing variables, do MM List Variables.  Each
variable's name and value (abbreviated if too long) will be shown.
A list of variables whose names contain <string> can be seen by doing
MM Variable Apropos<string>.

  To destroy a variable, do M(M.M Kill_Variable)<name> to run
MM Kill Variable.  This is necessary only in special situations.

File: CONV	Node: Major, Up: Top, Previous: Vars, Next: Submodes

Defining Major Modes.

  Each major mode is embodied by a command, such as MM TECO Mode or
MM Lisp Mode.  A major mode can be created simply by defining an
appropriate command.  However, major mode commands must work in a
particular way.

  Major modes make all their redefinitions by creating local
variables.  This is how each buffer can have its own major mode.
Buffer switching does not consciously "switch" modes;  it just swaps the
local variables, which has that effect.

  The first thing which each major mode command must do is eliminate
the local variables, if any, made by the previous major mode.  This is
done by calling M(M.M &_Init_Buffer_Locals).  All local variables of
the current buffer, except those made when the buffer was created, are
killed, and the global values reassert themselves.  In addition, &
Init Buffer Locals leaves Q.Q bound to the Make Local Q-register
command.

  Then, the major mode macro should create any local variables and
local q-registers that it wants.  Supplying a 1, argument to M.L
causes M.L to run much faster, assuming that the specified variable is
not already local.  Example: 1,(:I*;) M.L Comment_Start.  This is
recommended for major mode commands.  Command characters can be
redefined by using M.Q, since character definitions count as
q-registers.  Example:  M.M ^R_Indent_for_Lisp M.Q ^^I makes the
Tab character local to the current buffer, and redefines it for Lisp.

  Finally, the major mode macro should do

        1M(M.M &_Set_Mode_Line <mode name>  ^\

& Set Mode Line makes the new mode appear in the mode line, and the 1
as argument tells it to do everything else appropriate for finishing
up the change of major mode:  Setting the variable QMode, running
the value of <Mode> Mode Hook if it is defined.

  Exiting with ^\ causes the binding of Q.Q, left by & Init Buffer
Locals, to be popped, as well as any other bindings made by the major
mode macro.

File: CONV	Node: Submodes, Up: Top, Previous: Major, Next: Prefix

Submodes and ..F

  A submode is just a command which rebinds commands or variables and
then calls ^R recursively on the same buffer.  A submode's name
usually starts with the word "Edit", as in "Edit Picture".  Submodes
are to be distinguished from commands such as Edit ..D which call ^R
recursively on some other text.

  For submodes to indicate that they are active, the variable Submode
is provided.  Binding QSubmode to FOO causes [FOO] to appear in the
mode line after the name of the major mode.  However, you must call
& Set Mode Line yourself before entering ^R, and you must do an FN
command to cause & Set Mode Line to be called on the way out (even if
you come out via a throw or an MM Top Level).  Usually, the Edit FOO
submode will put FOO in the Submode variable.

  Submodes need not bind ..F to zero.  Because the buffer is not
bound, it works reasonably well to switch files, buffers or windows
inside a submode.  However, you stay inside the submode when you
switch, which you may not like.  Someday there may be a different
implementation of Submodes which makes them local to a buffer.

File: CONV	Node: Prefix, Up: Top, Previous: Submodes, Next: Hooks

Defining Prefix Characters.

  An EMACS environment can contain any number of prefix characters,
although EMACS normally contains only one - C-X.

  To define a prefix character, you must choose a single-dot
q-register to hold the dispatch table for it.  Call MM Make Prefix
Character<q-reg name> which returns a string which is a definition
of a prefix character which will look in the specified q-register for
the dispatch table.  Then put this string into the desired character's
definition.  Normally, dispatch tables are made 96 characters long.
If you want Rubout to be available as a subcommand, you must make it
128 characters long, which you can do by providing 128 as an argument
to Make Prefix Character.

  For example, a prefix character C-Y can be defined to dispatch
through q-register .Y by doing

	M(M.M Make Prefix Character).Y U.Y

After this, you can define individual subcommands by doing things like
M.MFOO U:.Y(A) which puts MM FOO on C-Y A.


How Prefix Characters Dispatch.

  All prefix characters made by Make Prefix Character, including the
initially present C-X, do their work by calling the contents of
q-register .P, providing the dispatch table as an argument.  .P reads
the input character, extracts the definition of the subcommand, and
returns it.  The prefix character itself then calls whatever .value P
returns.  You are free to redefine .P to get different behavior, as
long as you respect the interface conventions.  Take a look at the
source code for ^^ Prefix Character Driver, which is the default
contents of .P.


Making Self-documentation Work for Prefix Characters.

  In order for Where Is and Apropos to list all the ways a command can
be reached as a subcommand of a prefix character, all prefix
characters must be listed in QPrefix Char List.  This list has a
very ugly format:  there are six characters for each prefix
character.  The first two contain the 9-bit code for the prefix
character;  the top 2 bits in the first and the bottom 7 bits in the
second.  The next four characters are the name of the q-register which
contains the dispatch table used by the prefix character.  For
example, the default EMACS value of QPrefix Char List is ".X  ".

File: CONV	Node: Hooks, Up: Top, Previous: Prefix, Next: Dump

Hooks Provided by EMACS

  EMACS offers several hooks in the form of variables whose values
will be executed if nonzero at specific times.

Buffer Creation Hook

  This variable is executed when a new EMACS buffer is made by Select
Buffer, just after that buffer has been selected.  It might use M.L to
add a local variable, in case you want a certain variable to be local
in each buffer.  If you do this, you might want to change the global
value of Initial Local Count to the number of initial locals you
expect most buffers to have.  It works to have a different number, but
such buffers are given local values of Iitial Local Count, which is
wasteful if not necessary.  But if you do change Initial Local Count
globally, make sure you either create the additional locals in the
Main buffer at the same time, or give that buffer a suitable local
definition of Initial Local Count.

  The Buffer Creation Hook is not run when a buffer is created by
Append to Buffer.  This is obviously wrong, but since the buffer thus
created is never actually selected, there is no easy way to fix this.

Buffer Selection Hook

  This variable is executed whenever a buffer has just been selected.
It is most likely to be useful when made local to a particular buffer.

Buffer Deselection Hook

  This variable is executed whenever a buffer is just about to be
deselected.  It is most likely to be useful when made local to a
particular buffer.

Visit File Hook

  This variable is executed whenever a file has been visited.  All the
normal actions of visiting are already complete.

Set Mode Line Hook

  This variable is executed by & Set Mode Line.  If it returns a
string pointer as a value, that string will be stuck into the mode
line just before the closeparen.  The purpose of this variable is to
allow libraries which have state variables to display them in the mode
line.  So that several libraries can do this without interfering with
each other, each library should append its own hook to the variable
Set Mode Line Hook instead of setting it, and each library's
contribution must be able to accept an argument from a previous
library's contribution and append onto it.  For example, a reasonable
string to add " FOO" into the mode line would be:

    +0[1 FQ1"L :I1' :I* 1_FOO (]1)

This string, at the beginning of Set Mode Line Hook, would return a
string containing just " FOO";  if preceded by another such hook, it
would append the " FOO" onto what that other hook tried to return.

<libname> Setup Hook

  Each library's & Setup <libname> Library macro should check for the
existence of a <libname> Setup Hook variable, using 0FO..Q.  If the
variable exists and is nonzero, the setup macro should execute the
variable INSTEAD of its normal actions.

<Mode> Mode Hook

  Each major mode executes a mode hook variable after making its
normal redefinitions, but before updating the mode line.  Mode hooks
can create additional local variables or local q-registers (including
local ^R command redefinitions).

File: CONV	Node: Dump, Up: Top, Previous: Hooks, Next: Build

Dumping an EMACS Environment.

  Dumping an EMACS environment so that it can be loaded and run again
is no simple feat.  Since the environment, when dumped (with @EJ),
contains absolute pointers into the main EMACS library, we must make
sure that when the environment is run again the same version of that
library will be at the same place in the address space.  This is
accomplished by the Dump Environment command in the PURIFY library.

  The Dump Environment command in the PURIFY library has the ability
to dump out an EMACS environment so that, when loaded, it will reload
the same libraries that were loaded at dumping time - the same
versions, even, if multiple versions of the libraries are maintained.
Before calling Dump Environment, you must decide which of the loaded
libraries are to be reloaded by the dump file.  Given such a library,
called (say) "Mumble", you must set up a variable QMumble Library
Filename containing the filename to be used to reload that library.
This filename can contain a version number, if you are interested in
loading the same version as the dumped environment was made with (this
is necessary if any pointers to macros in that library exist in
q-registers or ^R character definitions, etc.).
Only libraries for which such variables are created will be reloaded
by the dumped environment.  Not all loaded libraries must be included,
but those which are must be contiguous, and include the first one
loaded.

  In addition, before calling Dump Environment you must specify the
TECO commands to be executed when the dump file is reloaded.  This is
done by creating a variable named QMM & Startup Mumble, where Mumble
stands for the contents of QEditor Name.  For EMACS, it is
called QMM & Startup EMACS.  The contents of q-register ..L are NOT used
when the dump file is started up, but they will reappear in ..L after
start up so that they will be run if the restarted dump file is
stopped and started again.  The QMM & Startup Mumble variable is killed
by Dump Environment, since it will be no use afterward.  Actually, if
you wish, you can have a command named just & Startup Mumble in one of
the libraries to be reloaded by the dump file, instead.

  The contents of q-register ..L when Dump Environment is called are
NOT used to initialize the dump file when it is reloaded.  However,
they do persist in ..L when the reloaded dumped environment is
running, and if that job is stopped and restarted again, the ..L will
be used.

  If your EMACS init file takes a long time to run, you can use Dump
Environment yourself after running the init file.  The QEMACS Library
Filename variable remains set up, so you need not worry about getting
the right version of it.  Just set up variables for the other
libraries that you want loaded, provide a suitable QMM & Startup
EMACS, and call Dump Environment.

File: CONV	Node: Build, Up: Top, Previous: Dump, Next: Wall Charts

How to Build and Dump a New EMACS.

  Before building a new dumped EMACS, you must of course Generate
up-to-date versions of the essential libraries.  This can be done by

	M-X RunEINIT? Generate

  The visible procedure for building a new EMACS is simply to do

	:NTECO EMACS;

which runs EMACS;.TECO. (INIT) in NTECO.  This leaves you in the TECO
top-level loop, typing TECO command strings, and should display an
EMACS-style mode line.  Then, to dump the EMACS, type

	MMRunPURIFYDump<filename>

which will dump the environment you have built.  Then kill the job.


How Building and Dumping Work

  Building a new EMACS environment has three phases:  loading
libraries, creating the "essential environment" necessary for EMACS
macros to work at all, and making the default set of command bindings.
Two other minor operations are the loading of the patch file, and the
purification of variable names.  The first phase is straightforward:
it simply loads the latest version of [PURE] :EJ, and also the EINIT
library which contains the code for performing the rest of the
initialization.

  Loading the essential environment is done by the & Load Essential
Environment command in EINIT.  This sets up things like q-registers
.M, .L, .V, .A, etc. as well as the option variables which many
commands assume the existence of.  Part of loading the essential
environment is loading the patch file EMACS;EPATCH >, which contains
corrected versions of macros changed since [PURE] was generated.  The
format of EPATCH is just that of a library source file;  EPATCH is
read in and MM Compile One Macro is done on each page of it.

  Loading the default EMACS environment is done by & Load Default
Environment in EINIT.  This is what defines C-N to run ^R Down Real.
The reason why it and & Load Essential Environment are not combined is
so that other command environments which use the EMACS execution
environment can be easily built.  Building such an environment would
involve calling & Load Essential Environment, and then using something
else instead of & Load Default Environment.

  At the end of building the environment, the variable names are
purified.  In order to save a few hundred words of impure core for all
users, the predefined variables' names and their comments are made to
live inside the [PURE] file instead of in impure string space.  The
necessary strings are created in [PURE] by the special file VARS,
which is included in the generation of the [PURE] library.  It inserts
the strings into the [PURE] file inside of another string, so that
they are conveniently out of the way.  Then, the Purify Variables
command in EINIT is used to look at each variable and replace its
impure name with the corresponding pure string, if there is one.


How Stand-alone RMAIL and INFO are Built and Dumped.

  Stand-alone INFO differs from an EMACS in that, on start-up, instead
of running the user's or the default init file, a particular procedure
(that of entering ^R-mode and then running MM INFO) is followed.
INFO is built by an EMACS init file which calls Dump Environment,
setting Editor Name to INFO and providing an appropriate MM & Startup
INFO macro to be used to start up the dump file when it is reloaded.
On the practical level, the EMACS init file for INFO actually
dumps the INFO, instead of returning and letting the user dump it.

  Stand-alone RMAIL is dumped by a TECO init file instead of an EMACS
init file, because while stand-alone INFO contains the standard EMACS
^R command definitions, stand-alone RMAIL contains the bare TECO ^R
command definitions.  It therefore cannot be built starting from a
whole EMACS.

  New versions of stand-alone RMAIL and INFO must be made for each new
TECO or EMACS version, just like new versions of the EMACS dump file.
The stand-alone RMAIL and INFO always load up the current version of
the RMAIL and INFO libraries, rather than the version which was
current when they were dumped, so new RMAIL and INFO dump files do not
generally need to be made when new versions of those libraries are
installed.

File: CONV	Node: Wall Charts, Up: Top, Previous: Build, Next: Qregs

Making Wall Charts

  Wall Charts are made by MM RunABSTRWall Chart<prefix chars>
with an empty buffer.  This produces a wall chart in the buffer,
describing the environment as it exists.  <prefix chars> is a list of
names of prefix characters, each of which should get a page describing
all of its subcommands.  The prefix characters are named as if you
were accessing their definitions as q-registers, such as ".X" for
C-X.  The names should be separated by Altmodes.  Two Altmodes end the
list of prefix character names.


Writing the Documentation Files EMACS CHART and EMACS DOC.

  These two files are produced from the self-documentation strings
within EMACS by the macros in the library ABSTR.  Simply doing

	M-X RunEINIT? Document

will update them according to the current environment.  Make sure that
you do this as a user who does not have an init file!  Otherwise, the
files will reflect your command definitions rather than the default.

File: CONV	Node: Qregs, Up: Top, Previous: Wall Charts, Next: FS^RPREV

Usage of Q-registers in EMACS and Macros Intended for EMACS 

  EMACS makes no use of non-dot q-regs except as saved and restored
local variables, unless the user  explicitly requests such use
with (say) ^XB or ^XX, except for M and R, and even those are not
depended on by the EMACS macros.  User macros may use non-dot q-regs
freely, but those intended for general use should not do so except as
local variables (pushed and popped).

  User macros should not use single or double dot q-regs except as
listed here.  If it is really essential, you should ask RMS to
allocate another single-dot q-reg for a specific use.  Normally, a
named variable is just as good.

	.A	MM & Autoload.  This macro loads a library temporarily
		and returns a pointer to a specified macro in it.
		For example, M.A DIREDClean Dir loads the DIRED
		library and returns a pointer to the Clean Dir macro
		in it.  FS :EJPAGE is pushed and left on the stack,
		so that the library will be flushed when the macro
		which invoked M.A exits and unwinds the stack.
        .B      The buffer table.  This is a q-vector which is
		subdivided into a section for each EMACS named buffer.
		The details of the format are described in a comment
		at the front of the EMACS source file BUFFER.

	.C	Set Variable Comment.
		Like .V, but creates a comment for the variable.
		<val>M.C <var> <comment> creates <var> if necessary,
		giving it the comment <comment> and the value <val>.
		<val> defaults to 0.  If the comment starts with
		"*", then the variable is an "option"
		and MM Alter Options will let the user edit it.
	.F	The "normal" (top-level) contents of ..F.
		When .F and ..F are not the same, EMACS knows that
		it is not safe to switch buffers, windows or files.
		.F should not be zero; that would lose.  See ..F.
	.H	The horizontal position "goal" for ^N and ^P
		commands.  If it is a small positive number, it
		is a temporary goal, which will be reset by
		each ^N or ^P not following another such.  The
		other possible values in .H are 1000000. plus a
		small number, which indicates a semipermanent goal
		that was established by ^R Set Goal Column and
		which it alone can alter.
	.I	^^ Prepare for Input.  Do M.I before doing an
		FI to read input.  The second argument, if any
		is the character to prompt with (default is in Q..0).
		The first argument is bit-decoded:  1 means that
		the control and meta prefix characters should be
		noticed, and 2 suppresses prompting and echoing
		(acts as if the characater being read is an independent
		command).
	.L	Make Local Variable.  Do M.L <var>  to make <var>
		into a local variable of the current buffer.
		If it already is local, nothing is changed.  If
		<var> didn't exist at all, 0M.V <var> is implied.
		The global value of <var> is not changed;  the local
		<var> starts off with that same value as well.
		If M.L is given a numeric argument, it becomes
		the new value of the (local) <var>.
	.M	^^ Macro Get.  M.M<name>$ returns a pointer to
		the macro <name>.  Normally, an error will
		occur if the name is undefined or ambiguous,
		but if 1, is given as argument, instead of an error,
		the value 0 or 1 will be returned.  Independently,
		a pointer to a file can be given as an argument,
		and the macro will be looked for in that file.
	.N	The ring buffer of minibuffer commands.  All commands
		that use the minibuffer and execute its contents
		normally push their commands onto this ring,
		so you can run them again easily.  Q.N is a q-vector
		whose 0th element is the most recent minibuffer.
	.P	M.P is the driver for "prefix" ^R characters,
		which read another character and dispatch on it.
		Whatever you put in .P should work like what is
		usually put there:  ^^ Prefix Character Driver.
		See Make Prefix Character.
	.V	Named Variable maker.  (Teco "altmode" Q-regs)
	.W	Is a flag that determines whether the word commands
		refer to LISP atoms.  It holds either a null string
		(if they do not) or an "@" (if they do).

	..F	normally holds the auto-filing secretary macro.
		Auto-saving is turned off by zeroing FS ^R MDLY,
		not by changing ..F.  Normally, .F contains the
		same thing as ..F.  Macros which call ^R recursively
		should bind ..F to 0, thus inhibiting auto-saving.
		Also, the fact that .F and ..F will then be different
		will serve as an indication that it is not safe to
		switch buffers, files or windows.  If you use a
		modified version of the secretary macro, you must
		store it in both ..F and .F for proper operation.
		To turn off the secretary macro globally, you should
		not simply set .F and ..F to zero, because then the
		functions that bind ..F to zero will not make it
		different from .F.  You must make a null string and
		put it in .F and ..F.
	..K	A qvector used to hold strings of deleted text
		by the ^R Kill ... and ^R Un-kill commands.
		The elements are the strings, in the order they
		were killed.  The beginning may be filled with zeros,
		if there are not enough remembered killed strings
		to use the whole qvector.
	..M	holds the keyboard macro call stack.
		See the file KBDMAC.

File: CONV	Node: FS^RPREV, Up: Top, Previous: Qregs, Next: Debug

FS ^R LAST / FS ^R PREV Convention

  Some commands set FS ^R LAST to a special value not in
the range of 9-bit characters, to make it possible to test
whether the previous command was in a certain class without
having to know which characters various macros are on.
These are the values used:

512+27		is set at times in minibuffering, when the
 (1033 octal)	most recent character was an altmode but a
		following altmode should not exit.

1001 (decimal)  is set by deleting commands.
		This allows multiple consecutive deletions
		to be combined in the ..K ring.

1002		is set by the vertical-motion commands
		so that repeated vertical motion commands
		can use the same horizontal position as a goal.

1003		signals that it is OK for m-Y (^R Un-kill Pop)
		to work even though the current region is not
		on the kill-ring.  This is used by commands like
		Fill Region which save the region then do a simple
		but possibly dangerous transformation to it.

File: CONV	Node: Debug, Up: Top, Previous: FS^RPREV

Debugging

  For debugging, make use of the macro MM TCompile, which compresses
the definition of the macro you are pointing at and makes it available
to M.M.  This makes it possible to test a new version of a macro
without purifying the whole file containing it.  Insert a ^R command
into the definition to make a "breakpoint" which will allow you to
look around.  Exiting the ^R will cause execution of the macro to
resume.  To test-compile the macro and put it on a character, give the
name of the character as a q-register as an argument to MM Tcompile,
as in MM TCompile.N to set C-N's definition.  Any q-register name
is allowed there.

  The default EMACS error handler runs MM Backtrace after every
error, if the first character you type is "?".  This feature allows
you to examine the stack, as well as all q-registers and other
variables.  MM DescribeBacktrace for details.  If QDebug is
nonzero, you can type "?" to get a backtrace after a quit as well as
after an error. 

*note TDEBUG: (TDEBUG)Top, for info on the superb TDEBUG package
which allows you to step through the execution of a macro,
and examine the macro and q-register pdls.
